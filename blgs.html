<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>无限合成检索工具</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px; background-color: #f4f7f6; }
        .container { max-width: 1000px; margin: auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); }
        h1 { color: #007bff; border-bottom: 3px solid #007bff; padding-bottom: 10px; margin-bottom: 20px; }
        
        button { padding: 8px 12px; margin: 5px 10px 5px 0; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: background-color 0.3s; }
        .btn-explore { background-color: #007bff; color: white; }
        .btn-explore-pause { background-color: #dc3545; color: white; }
        .btn-data { background-color: #6c757d; color: white; }
        .btn-import-export { background-color: #28a745; color: white; }
        .btn-copy { background-color: #ffc107; color: #333; margin-left: 10px; padding: 5px 10px; font-size: 13px;}
        .btn-clear { background-color: #dc3545; color: white; }
        .btn-explore:hover { background-color: #0056b3; }
        .btn-explore-pause:hover { background-color: #c82333; }
        .btn-data:hover { background-color: #5a6268; }
        .btn-import-export:hover { background-color: #1e7e34; }
        .btn-copy:hover { background-color: #e0a800; }
        .btn-clear:hover { background-color: #c82333; }
        
        /* 手动合成区域样式 */
        #manual_synthesis_controls {
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        #manual_synthesis_controls input {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box; /* 确保 padding 不影响宽度 */
        }
        #synthesis_status {
            color: #dc3545; 
            font-weight: bold;
            margin-left: 15px;
        }

        pre, textarea { background-color: #e9ecef; padding: 15px; border-radius: 8px; overflow-x: auto; white-space: pre-wrap; word-break: break-all; margin-top: 10px; font-size: 12px; border: 1px solid #ccc;}
        .log-area { max-height: 250px; overflow-y: scroll; }

        /* --- 表格容器和样式 (保持不变) --- */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 25px;
            border-left: 5px solid #ffc107;
            padding-left: 10px;
        }
        .section-header h3 { margin: 0; color: #333; }

        .fixed-header-table {
            display: flex;
            flex-direction: column;
            height: 300px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: white;
            margin-top: 10px;
        }
        .table-header {
            display: flex;
            font-weight: bold;
            background-color: #f1f1f1;
            padding: 8px 15px;
            border-bottom: 1px solid #ccc;
            flex-shrink: 0; 
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            font-size: 13px;
        }
        .table-header input {
            width: 90%;
            padding: 2px 0 2px 5px;
            margin-top: 2px;
            font-size: 11px;
            border: 1px solid #ddd;
            display: block;
        }
        .table-body {
            overflow-y: scroll;
            font-size: 12px;
        }
        .table-row {
            display: flex;
            padding: 6px 15px;
            border-bottom: 1px solid #eee;
        }
        .table-row:last-child { border-bottom: none; }

        /* Item Table Columns */
        .col-seq { flex: 0.5; text-align: right; padding-right: 5px; font-weight: normal; color: #999;} 
        .col-id { flex: 1.5; }
        .col-depth { flex: 1; text-align: center;}
        .col-width { flex: 1; text-align: center;}
        .col-name { flex: 4; }

        /* Recipe Detailed Table Columns */
        .col-lid, .col-rid, .col-pid, .col-simple { flex: 1.25; text-align: center; }

        /* Recipe Simple List Column */
        .col-simple-list { flex: 4.75; text-align: left; padding-left: 5px; }
        
        .progress-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
        }
        .progress-bar-style {
            height: 10px;
            width: 250px;
            margin-left: 10px;
        }

        /* 统计信息样式优化 */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            background-color: #fff8e1;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #ffd700;
        }
        .stats-item {
            padding: 5px;
            border-left: 3px solid #ffc107;
            padding-left: 10px;
            word-wrap: break-word; 
        }
        .stats-item strong { color: #333; }
        .stats-item span { color: #007bff; font-weight: bold;}
        .stats-list { white-space: pre-line; margin-top: 5px; }
        
        /* 可视化统计样式 */
        .stats-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        .viz-container {
            flex: 1;
            min-width: 200px;
        }
        .viz-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .viz-label {
            width: 40px;
            text-align: right;
            margin-right: 8px;
        }
        .viz-bar {
            height: 16px;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 3px;
            transition: width 0.3s ease;
            min-width: 3px;
            position: relative;
        }
        .viz-count {
            margin-left: 8px;
            font-weight: bold;
            color: #333;
        }
        
        /* 深度和宽度统计在同一行 */
        .depth-width-stats {
            grid-column: span 3;
            display: flex;
            gap: 20px;
        }
        .depth-stats, .width-stats {
            flex: 1;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>无限合成检索工具</h1>
        <p>Powered by HypnosPD</p>

        <h2>操作控制</h2>
        <button id="toggle-explore-btn" class="btn-explore" onclick="app.toggleExploration()">1. 开始遍历</button>
        <button class="btn-data" onclick="app.exportData()">2. 导出 JSON</button>
        <button class="btn-data" onclick="app.importData()">3. 导入 JSON</button>
        <button class="btn-import-export" onclick="app.exportRecipesAsText()">4. 导出合成表 (TXT)</button>
        <button class="btn-import-export" onclick="app.importRecipesFromText()">5. 导入合成表 (TXT)</button>
        <button class="btn-clear" onclick="app.clearLocalData()">6. 清空本地数据</button>
        
        <br>
        
        <h2>手动合成</h2>
        <div id="manual_synthesis_controls">
            <input type="text" id="material_a_name" placeholder="素材 A 名称 (需已发现)" list="item_names_datalist" style="width: 200px; margin-right: 10px;">
            <input type="text" id="material_b_name" placeholder="素材 B 名称 (需已发现)" list="item_names_datalist" style="width: 200px; margin-right: 10px;">
            <span style="font-weight: bold; margin-right: 10px;">=</span>
            <span id="result_c_name" style="width: 200px; margin-right: 15px; padding: 8px 10px; background-color: #f8f9fa; border-radius: 4px; min-height: 18px;">?</span>
            <button id="synthesize_btn" class="btn-import-export" onclick="app.manualSynthesize()">合成</button>
            <p id="synthesis_status"></p>
        </div>

        <h2>系统日志</h2>
        <pre id="log_area" class="log-area"></pre>

        <h2>当前状态</h2>
        <div class="status-box">
            <p>
                <strong>遍历状态:</strong> <span id="traversal_status">已暂停</span> |
                <strong>Max Positive ID:</strong> <span id="max_id">N/A</span> | 
                <strong>Min Negative ID:</strong> <span id="min_id">N/A</span> |
                <strong>探索进度:</strong> <span id="exp_depth">N/A</span>
            </p>
            
            <div class="progress-container">
                <strong>当前深度进度 (D=<span id="current_depth">N/A</span>):</strong>
                <span id="progress_text">N/A</span>
                <progress id="progress_bar" value="0" max="100" class="progress-bar-style"></progress>
            </div>

            <div id="statistics_block" class="stats-grid">
                <!-- 统计信息将通过JavaScript动态生成 -->
            </div>

            <div class="section-header">
                <h3>所有 Item</h3>
                <button class="btn-copy" onclick="copyContent('item_list')">复制全部内容</button>
            </div>
            <div id="item_list" class="fixed-header-table"></div>

            <div class="section-header">
                <h3>所有 Recipe</h3>
                <div>
                    <button class="btn-data" onclick="app.toggleRecipeDisplay()">切换合成表</button>
                    <button class="btn-copy" onclick="copyContent('recipe_list')">复制全部内容</button>
                </div>
            </div>
            <div id="recipe_list" class="fixed-header-table"></div>
        </div>
    </div>
    
    <datalist id="item_names_datalist"></datalist>

    <script>
        // ----------------------------------------------------
        // Z. 全局工具函数
        // ----------------------------------------------------
        function log(message) {
            const logArea = document.getElementById('log_area');
            const now = new Date().toLocaleTimeString('zh-CN');
            logArea.textContent += `[${now}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight; 
        }

        async function copyContent(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            let contentToCopy = '';
            
            const headerSpans = element.querySelector('.table-header').children;
            let headerText = '';
            Array.from(headerSpans).slice(1).forEach(span => {
                const text = span.querySelector('input') ? span.textContent.replace(span.querySelector('input').value, '').trim() : span.textContent.trim();
                headerText += text + '\t';
            });
            contentToCopy += headerText.trim() + '\n';
            
            const rows = element.querySelectorAll('.table-body .table-row');
            rows.forEach(row => {
                if (row.style.display !== 'none') {
                    const rowContent = Array.from(row.children).slice(1).map(span => span.textContent.trim()).join('\t');
                    contentToCopy += rowContent + '\n';
                }
            });
            
            try {
                await navigator.clipboard.writeText(contentToCopy);
                log(`[复制] 内容已成功复制到剪贴板。`);
            } catch (err) {
                log(`[复制失败] 请检查浏览器权限或手动复制。`);
            }
        }
        
        /**
         * 自定义 ID 比较函数，用于排序：
         * 1. 正数 ID 优先 (确定 Item)
         * 2. 正数 ID 按值升序
         * 3. 负数 ID 在后 (非确定 Item)
         * 4. 负数 ID 按绝对值升序 (即 -1, -2, -3...)
         */
        function customIdCompare(idA, idB) {
            const isAPositive = idA >= 0;
            const isBPositive = idB >= 0;

            // 1. Positive vs Negative: Positive first
            if (isAPositive && !isBPositive) return -1;
            if (!isAPositive && isBPositive) return 1;

            // 2. Both Positive: standard ascending
            if (isAPositive && isBPositive) {
                return idA - idB;
            }

            // 3. Both Negative: absolute value ascending
            if (!isAPositive && !isBPositive) {
                return Math.abs(idA) - Math.abs(idB);
            }
            
            return 0; // Should not happen
        }
        
        // ----------------------------------------------------
        // Y. 全局状态存储 (滚动和筛选)
        // ----------------------------------------------------
        const scrollPositions = {
            itemList: 0,
            recipeList: 0
        };

        const filterValues = {
            'id': '',
            'name': '',
            'depth': '',
            'width': '',
            'recipe_simple_list': '', 
            'lid': '',                
            'rid': '',                
            'pid': '',                
            'simple': ''              
        };
        
        // ----------------------------------------------------
        // X. 表格筛选函数 (保持不变)
        // ----------------------------------------------------
        function filterTable(elementId, filterColumn) {
            const filterInput = document.getElementById(`filter-${filterColumn}`);
            
            const filterValue = filterInput ? filterInput.value.toLowerCase().trim() : (filterValues[filterColumn] || '').toLowerCase().trim();
            filterValues[filterColumn] = filterValue; 

            const tableBody = document.getElementById(elementId).querySelector('.table-body');
            if (!tableBody) return;

            const isItemTable = (elementId === 'item_list');
            const isSimpleRecipe = (elementId === 'recipe_list' && app.recipeDisplayMode);
            const itemColIndexMap = { 'id': 1, 'depth': 2, 'width': 3, 'name': 4 }; 
            const detailedRecipeColIndexMap = { 'lid': 1, 'rid': 2, 'pid': 3, 'simple': 4 };
            const simpleRecipeColIndexMap = { 'recipe_simple_list': 1 };

            Array.from(tableBody.children).forEach(row => {
                const cells = Array.from(row.children);
                let isMatch = true;
                
                if (isItemTable) {
                    const idText = cells[itemColIndexMap['id']].textContent.split('(')[0].trim();
                    if (filterValues['id'] && !idText.includes(filterValues['id'])) isMatch = false;

                    const nameText = cells[itemColIndexMap['name']].textContent.toLowerCase();
                    if (isMatch && filterValues['name'] && !nameText.includes(filterValues['name'])) isMatch = false;
                    
                    const depthText = cells[itemColIndexMap['depth']].textContent.trim();
                    if (isMatch && filterValues['depth']) {
                        if (String(depthText) !== filterValues['depth']) isMatch = false;
                    }
                    
                    const widthText = cells[itemColIndexMap['width']].textContent.trim();
                    if (isMatch && filterValues['width']) {
                        if (String(widthText) !== filterValues['width']) isMatch = false;
                    }

                } else if (isSimpleRecipe) {
                    const recipeText = cells[simpleRecipeColIndexMap['recipe_simple_list']].textContent.toLowerCase();
                    if (filterValues['recipe_simple_list'] && !recipeText.includes(filterValues['recipe_simple_list'])) isMatch = false;

                } else {
                    const lidText = cells[detailedRecipeColIndexMap['lid']].textContent.trim();
                    if (filterValues['lid'] && !lidText.includes(filterValues['lid'])) isMatch = false;

                    const ridText = cells[detailedRecipeColIndexMap['rid']].textContent.trim();
                    if (isMatch && filterValues['rid'] && !ridText.includes(filterValues['rid'])) isMatch = false;
                    
                    const pidText = cells[detailedRecipeColIndexMap['pid']].textContent.trim();
                    if (isMatch && filterValues['pid'] && !pidText.includes(filterValues['pid'])) isMatch = false;
                    
                    const simpleText = cells[detailedRecipeColIndexMap['simple']].textContent.toLowerCase().trim();
                    const simpleFilter = filterValues['simple'].toLowerCase().trim();
                    if (isMatch && simpleFilter && !simpleText.includes(simpleFilter)) isMatch = false;
                }

                row.style.display = isMatch ? 'flex' : 'none';
            });
        }
        
        // ----------------------------------------------------
        // W. 进度条计算函数 (保持不变)
        // ----------------------------------------------------
        function calculateProgress(S_D_length, A_idx, B_idx) {
            if (S_D_length === 0) return { current: 0, total: 0, percentage: 0 };
            
            const total = S_D_length * (S_D_length + 1) / 2;
            let completedSteps = 0;
            
            for (let i = 0; i < A_idx; i++) {
                completedSteps += (S_D_length - i);
            }
            
            completedSteps += (B_idx - A_idx + 1);
            
            const percentage = (completedSteps / total) * 100;
            
            return {
                current: completedSteps,
                total: total,
                percentage: isNaN(percentage) ? 0 : Math.min(100, percentage)
            };
        }

        // ----------------------------------------------------
        // V. 统计信息计算和可视化
        // ----------------------------------------------------
        function calculateStatistics(state) {
            const stats = {
                totalItems: state.items.size,
                determinedItems: 0,
                undeterminedItems: 0,
                totalRecipes: state.recipes.size,
                simpleRecipes: 0,
                itemsPerDepth: {},
                itemsPerWidth: {}
            };

            state.items.forEach(item => {
                if (item.isDetermined) {
                    stats.determinedItems++;
                    
                    const D = item.depth;
                    stats.itemsPerDepth[D] = (stats.itemsPerDepth[D] || 0) + 1;
                    
                    const W = item.width;
                    stats.itemsPerWidth[W] = (stats.itemsPerWidth[W] || 0) + 1;
                } else {
                    stats.undeterminedItems++;
                }
            });
            
            state.recipes.forEach((isSimple) => {
                if (isSimple) {
                    stats.simpleRecipes++;
                }
            });
            
            return stats;
        }

        // 生成可视化统计HTML
        function generateVisualizationHTML(stats) {
            // 深度统计可视化
            const depthEntries = Object.entries(stats.itemsPerDepth).sort(([d1], [d2]) => Number(d1) - Number(d2));
            const maxDepthCount = Math.max(...Object.values(stats.itemsPerDepth), 1);
            
            let depthVizHTML = '<div class="depth-stats"><strong>各深度Item数:</strong><div class="stats-visualization">';
            depthEntries.forEach(([depth, count]) => {
                const percentage = (count / maxDepthCount) * 100;
                depthVizHTML += `
                    <div class="viz-bar-container">
                        <div class="viz-label">D${depth}</div>
                        <div class="viz-bar" style="width: ${percentage}%"></div>
                        <div class="viz-count">${count}</div>
                    </div>
                `;
            });
            depthVizHTML += '</div></div>';
            
            // 宽度统计可视化
            const widthEntries = Object.entries(stats.itemsPerWidth).sort(([w1], [w2]) => Number(w1) - Number(w2));
            const maxWidthCount = Math.max(...Object.values(stats.itemsPerWidth), 1);
            
            let widthVizHTML = '<div class="width-stats"><strong>各宽度Item数:</strong><div class="stats-visualization">';
            widthEntries.forEach(([width, count]) => {
                const percentage = (count / maxWidthCount) * 100;
                widthVizHTML += `
                    <div class="viz-bar-container">
                        <div class="viz-label">W${width}</div>
                        <div class="viz-bar" style="width: ${percentage}%"></div>
                        <div class="viz-count">${count}</div>
                    </div>
                `;
            });
            widthVizHTML += '</div></div>';
            
            return { depthVizHTML, widthVizHTML };
        }


        // ====================================================================
        // I. 数据结构定义
        // ====================================================================
        class Item {
            constructor(id, name, depth = -1, width = 1) {
                this.id = id; this.name = name; this.depth = depth; this.width = width;
            }
            get isDetermined() { return this.id >= 0; }
        }

        class Recipe {
            constructor(idA, idB, idC, simple = false) {
                const [lid, rid] = idA <= idB ? [idA, idB] : [idB, idA];
                this.id = [lid, rid, idC]; 
                this.simple = simple; 
            }
            get key() { return JSON.stringify(this.id); }
        }

        class State {
            constructor() {
                this.elements = ['金', '木', '水', '火', '土']; 
                this.recipes = new Map();   
                this.items = new Map();     
                this.max_positive_id = -1;
                this.min_negative_id = -1;
                this.exploration_depth = 0; 
                this.exploration_A_idx = 0; 
                this.exploration_B_idx = 0; 
                this.traversal_complete = true; 
            }
            getSimpleRecipesForItem(itemId) {
            const simpleRecipes = [];
            this.recipes.forEach((isSimple, key) => {
                if (isSimple === true) {
                    const [,, pid] = JSON.parse(key);
                    if (pid === itemId) {
                        simpleRecipes.push(key);
                    }
                }
            });
            return simpleRecipes;
        }
        }

        // ====================================================================
        // II. 状态管理与核心算法实现
        // ====================================================================

        class SynthesisApp {
            constructor() {
                this.state = new State();
                this.isTraversing = false; 
                this.recipeDisplayMode = false;
                this.traversalTimeout = null;
            }

            // A. API 调用 (保持不变)
            async callSynthesisApi(itemAName, itemBName) {
                const encodedItemA = encodeURIComponent(itemAName);
                const encodedItemB = encodeURIComponent(itemBName);
                const apiUrl = `https://hc.tsdo.in/api?itemA=${encodedItemA}&itemB=${encodedItemB}`;
                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) return null;
                    const data = await response.json();
                    return data.item || null; 
                } catch (error) {
                    return null;
                }
            }
            
            // B. 持久化与辅助函数 (保持不变)
            saveState() {
                const data = {
                    items: Array.from(this.state.items.entries()), 
                    recipes: Array.from(this.state.recipes.entries()), 
                    max_positive_id: this.state.max_positive_id,
                    min_negative_id: this.state.min_negative_id,
                    exploration_depth: this.state.exploration_depth,
                    exploration_A_idx: this.state.exploration_A_idx,
                    exploration_B_idx: this.state.exploration_B_idx,
                    traversal_complete: this.state.traversal_complete,
                    recipeDisplayMode: this.recipeDisplayMode 
                };
                try {
                    localStorage.setItem('synthesisAppState', JSON.stringify(data));
                } catch (e) {
                    log("警告: 无法保存状态到本地存储。");
                }
            }

            loadState() {
                try {
                    const jsonStr = localStorage.getItem('synthesisAppState');
                    if (!jsonStr) return false;

                    const data = JSON.parse(jsonStr);
                    
                    this.state = new State();
                    this.state.items = new Map(data.items.map(([id, item]) => [Number(id), Object.assign(new Item(), item)]));
                    this.state.recipes = new Map(data.recipes); 
                    this.state.max_positive_id = data.max_positive_id;
                    this.state.min_negative_id = data.min_negative_id;
                    this.state.exploration_depth = data.exploration_depth;
                    this.state.exploration_A_idx = data.exploration_A_idx;
                    this.state.exploration_B_idx = data.exploration_B_idx;
                    this.state.traversal_complete = data.traversal_complete;
                    this.recipeDisplayMode = data.recipeDisplayMode !== undefined ? data.recipeDisplayMode : false;
                    
                    return true;

                } catch (e) {
                    log(`加载状态失败: ${e.message}。将尝试重新初始化。`);
                    localStorage.removeItem('synthesisAppState');
                    this.state = new State(); 
                    return false;
                }
            }

            getItemNameById(id) {
                return this.state.items.get(id)?.name || `ID:${id}(未知)`;
            }

            getElementByName(name) {
                for (const item of this.state.items.values()) {
                    if (item.name === name) return item;
                }
                return null;
            }


            // C. 状态变更算法 (保持不变)
            promoteItemID(id_old, id_new, itemObj, skipSave = false) { 
                log(`   -> [状态升级] ${itemObj.name}: ID ${id_old} -> ${id_new}`);
                this.state.items.delete(id_old);
                itemObj.id = id_new;
                this.state.items.set(id_new, itemObj);
                
                const newRecipesMap = new Map(); 

                this.state.recipes.forEach((isSimple, key) => { 
                    const recipeArr = JSON.parse(key);
                    let [lid, rid, pid] = recipeArr;
                    let currentSimple = isSimple; 

                    if (pid === id_old) { pid = id_new; }
                    if (lid === id_old) { lid = id_new; } 
                    else if (rid === id_old) { rid = id_new; }

                    const [new_lid, new_rid] = lid <= rid ? [lid, rid] : [rid, lid];
                    const newKey = JSON.stringify([new_lid, new_rid, pid]);
                    
                    newRecipesMap.set(newKey, currentSimple); 
                });
                this.state.recipes = newRecipesMap; 
                
                if (!skipSave) { 
                    this.saveState(); 
                }
            }

            async addRecipe(idA, idB, resultName, isExploration = false, skipSave = false) { 
                const itemA = this.state.items.get(idA);
                const itemB = this.state.items.get(idB);
                if (!itemA || !itemB) return null;

                let itemC = this.getElementByName(resultName);
                
                const shouldSave = !skipSave; 

                const D_new = Math.max(itemA.depth, itemB.depth) + 1;
                const W_new = itemA.width + itemB.width;
                let is_shortest_path_found = false;
                let should_update_simple = false;

                // 检查是否已存在相同结果的recipe
                if (itemC && itemC.isDetermined) {
                    const existingRecipeKey = new Recipe(idA, idB, itemC.id).key;
                    if (this.state.recipes.get(existingRecipeKey) === true) {
                        return null; 
                    } 
                }

                if (!itemC) {
                    if (isExploration) {
                        this.state.max_positive_id++;
                        itemC = new Item(this.state.max_positive_id, resultName, D_new, W_new);
                        this.state.items.set(itemC.id, itemC);
                        is_shortest_path_found = true;
                        should_update_simple = true;
                        log(`   -> [新发现] ${resultName}: ID ${itemC.id}, Depth ${D_new}`);
                    } else {
                        this.state.min_negative_id--;
                        const temp_id = this.state.min_negative_id;
                        itemC = new Item(temp_id, resultName, D_new, W_new); 
                        this.state.items.set(temp_id, itemC);
                        log(`   -> [非探创建] ${resultName}: 暂定 ID ${temp_id}, Depth ${D_new}`);
                    }
                } else {
                    const D_old = itemC.depth;
                    
                    if (D_new < D_old) {
                        // 找到更短路径
                        itemC.depth = D_new;
                        itemC.width = W_new;
                        is_shortest_path_found = true;
                        should_update_simple = true;
                        
                        if (itemC.id < 0) {
                            this.state.max_positive_id++;
                            this.promoteItemID(itemC.id, this.state.max_positive_id, itemC, !isExploration); 
                        } else {
                            log(`   -> [路径优化] ${itemC.name}: Depth ${D_old} -> ${D_new}`);
                        }
                    } else if (D_new === D_old) {
                        // 深度相同，检查宽度优化
                        if (W_new < itemC.width) {
                            itemC.width = W_new;
                            is_shortest_path_found = true;
                            should_update_simple = true; // 关键修改：深度相同但宽度更小时也更新simple
                            log(`   -> [Width优化] ${itemC.name}: Width ${itemC.width} -> ${W_new}`);
                        }
                        
                        if (isExploration) {
                            if (itemC.id < 0) {
                                is_shortest_path_found = true;
                                should_update_simple = true;
                                this.state.max_positive_id++;
                                this.promoteItemID(itemC.id, this.state.max_positive_id, itemC, false); 
                            } else if (itemC.id > 0 && should_update_simple) {
                                // 确定状态元素，在宽度优化时也要更新simple
                                is_shortest_path_found = true;
                            }
                        }
                    }
                }

                const pid_final = itemC.id; 
                const recipeKey = new Recipe(itemA.id, itemB.id, pid_final).key;
                
                // 关键修改：确保每个元素只有一个simple recipe
                let currentIsSimple = false;
                
                if (isExploration && is_shortest_path_found) {
                    // 检查是否应该将此recipe设为simple
                    if (should_update_simple) {
                        currentIsSimple = true;
                        
                        // 清理该元素的其他simple recipe
                        this._clearOtherSimpleRecipes(pid_final, recipeKey);
                    }
                }

                if (this.state.recipes.has(recipeKey)) {
                    const existingIsSimple = this.state.recipes.get(recipeKey);

                    if (existingIsSimple === true) return null; 

                    if (currentIsSimple === true) {
                        this.state.recipes.set(recipeKey, true); 
                        log(`   -> [更新配方] ${itemA.name} + ${itemB.name} -> ${itemC.name}. 状态升级为 Simple: True`);
                        if (shouldSave) this.saveState(); 
                        return { key: recipeKey, simple: true };
                    }
                } else {
                    this.state.recipes.set(recipeKey, currentIsSimple);
                    log(`   -> [记录配方] ${itemA.name} + ${itemB.name} -> ${itemC.name}. Simple: ${currentIsSimple}`);
                    if (shouldSave) this.saveState(); 
                    return { key: recipeKey, simple: currentIsSimple };
                }
                
                return null;
            }

            // 新增方法：清理元素的其它simple recipe
            _clearOtherSimpleRecipes(targetPid, currentRecipeKey) {
                let clearedCount = 0;
                
                // 遍历所有recipe，找到相同pid但不同key的simple recipe
                this.state.recipes.forEach((isSimple, key) => {
                    if (isSimple === true && key !== currentRecipeKey) {
                        const [,, pid] = JSON.parse(key);
                        if (pid === targetPid) {
                            this.state.recipes.set(key, false);
                            clearedCount++;
                            
                            // 记录被清理的recipe信息
                            const [lid, rid] = JSON.parse(key);
                            const nameA = this.getItemNameById(lid);
                            const nameB = this.getItemNameById(rid);
                            const nameC = this.getItemNameById(pid);
                            log(`   -> [清理Simple] ${nameA} + ${nameB} = ${nameC} 的Simple标记已移除`);
                        }
                    }
                });
                
                if (clearedCount > 0) {
                    log(`   -> [Simple清理完成] 为元素 ${this.getItemNameById(targetPid)} 清理了 ${clearedCount} 个旧的simple recipe`);
                }
            }
            
            // D. 遍历控制 (保持不变)
            async exploreNextDepth() {
                if (!this.isTraversing) return false; 
                
                const D_target = this.state.exploration_depth;
                log(`\n--- 开始探索深度 D=${D_target} ---`);
                
                const S_D = Array.from(this.state.items.values()).filter(item => item.isDetermined && item.depth <= D_target);
                S_D.sort((a, b) => a.id - b.id);
                
                if (S_D.length === 0 && D_target > 0) {
                    log("遍历完成，没有更多确定状态的元素可供探索。");
                    return false;
                }

                let hasChanges = false;
                
                let currentAIdx = this.state.exploration_A_idx;
                let currentBIdx = this.state.exploration_B_idx;
                
                for (let i = currentAIdx; i < S_D.length; i++) {
                    const itemA = S_D[i];
                    const startB = (i === currentAIdx) ? currentBIdx : i;
                    
                    for (let j = startB; j < S_D.length; j++) {
                        if (!this.isTraversing) {
                            this.state.exploration_A_idx = i;
                            this.state.exploration_B_idx = j;
                            log(`遍历在 D=${D_target} 处暂停。`);
                            return false; 
                        }

                        const itemB = S_D[j];

                        this.state.exploration_A_idx = i;
                        this.state.exploration_B_idx = j;
                        
                        const resultName = await this.callSynthesisApi(itemA.name, itemB.name);
                        
                        if (resultName) {
                            const old_max_id = this.state.max_positive_id;
                            const recipeResult = await this.addRecipe(itemA.id, itemB.id, resultName, true); 
                            
                            if (this.state.max_positive_id > old_max_id || (recipeResult && recipeResult.simple)) {
                                hasChanges = true;
                            }
                        }
                        
                        if ((i === currentAIdx && j % 2 === 0) || j === S_D.length - 1) { 
                            this.renderStatus(true, true); 
                        }
                    }
                    this.state.exploration_B_idx = i + 1; 
                }

                log(`深度 D=${D_target} 探索完毕。`);
                this.state.exploration_A_idx = 0;
                this.state.exploration_B_idx = 0;
                this.state.exploration_depth++;
                this.state.traversal_complete = true;
                this.saveState();
                return hasChanges;
            }
            
            toggleExploration() {
                if (this.isTraversing) {
                    this.isTraversing = false;
                    clearTimeout(this.traversalTimeout);
                    log("遍历流程已暂停。");
                } else {
                    if (this.state.items.size === 0 && this.state.max_positive_id < 0) {
                        log("警告: Item 列表为空，尝试重新初始化。");
                        this.initialize();
                    }
                    this.isTraversing = true;
                    log("遍历流程开始/恢复...");
                    this._runExplorationLoop();
                }
                this._updateControlUI();
                this.renderStatus();
            }

            async _runExplorationLoop() {
                let changesFound = true;
                const maxDepth = 5; 
                
                while(this.isTraversing && changesFound && this.state.exploration_depth < maxDepth) {
                    this.state.traversal_complete = false;
                    this.renderStatus(); 
                    
                    changesFound = await this.exploreNextDepth();
                    
                    if (!this.isTraversing) return; 

                    if (!changesFound) {
                        log("所有最短路径已穷尽。遍历流程结束。");
                        break;
                    }
                    this.state.traversal_complete = true;
                    await new Promise(resolve => this.traversalTimeout = setTimeout(resolve, 100)); 
                }

                if (this.isTraversing) {
                    this.isTraversing = false;
                    log(`遍历流程已结束或达到最大深度限制 (${maxDepth})。`);
                }
                this._updateControlUI();
                this.renderStatus();
            }

            // E. UI 交互 - 扩展 _updateControlUI 来管理手动合成功能 (保持不变)
            _updateControlUI() {
                const btn = document.getElementById('toggle-explore-btn');
                const status = document.getElementById('traversal_status');
                
                const isPaused = !this.isTraversing;
                const manualInputs = document.querySelectorAll('#manual_synthesis_controls input');
                const manualButton = document.getElementById('synthesize_btn');
                const synthesisStatusEl = document.getElementById('synthesis_status');


                if (this.isTraversing) {
                    btn.textContent = '1. 暂停遍历';
                    btn.className = 'btn-explore-pause';
                    status.textContent = '正在运行...';
                } else {
                    const verb = !this.state.traversal_complete ? '恢复' : '开始';
                    btn.textContent = `1. ${verb}遍历`;
                    btn.className = 'btn-explore';
                    status.textContent = '已暂停';
                }
                
                // 控制手动合成功能状态
                manualInputs.forEach(input => input.disabled = !isPaused);
                if (manualButton) manualButton.disabled = !isPaused;
                
                if (!isPaused) {
                    synthesisStatusEl.textContent = '遍历运行时，手动合成功能禁用。';
                } else {
                    // 仅在暂停且状态栏被禁用文字占用时才清空
                    if (synthesisStatusEl.textContent === '遍历运行时，手动合成功能禁用。') {
                        synthesisStatusEl.textContent = '';
                    }
                }
            }
            
            toggleRecipeDisplay() {
                this.recipeDisplayMode = !this.recipeDisplayMode;
                filterValues['recipe_simple_list'] = '';
                filterValues['lid'] = '';
                filterValues['rid'] = '';
                filterValues['pid'] = '';
                filterValues['simple'] = '';
                this.renderStatus();
                this.saveState();
                log(`配方显示模式切换为: ${this.recipeDisplayMode ? '简洁列表' : '详细表格'}`);
            }

            // F. 修改手动合成方法 - 自动调用API获取结果
            async manualSynthesize() {
                if (this.isTraversing) {
                    document.getElementById('synthesis_status').textContent = '请先暂停遍历。';
                    return;
                }

                const nameA = document.getElementById('material_a_name').value.trim();
                const nameB = document.getElementById('material_b_name').value.trim();
                const statusEl = document.getElementById('synthesis_status');
                const resultEl = document.getElementById('result_c_name');
                statusEl.textContent = '';
                resultEl.textContent = '?';
                resultEl.style.color = '#333';

                if (!nameA || !nameB) {
                    statusEl.textContent = '素材名称不能为空。';
                    return;
                }

                const itemA = this.getElementByName(nameA);
                const itemB = this.getElementByName(nameB);

                if (!itemA || !itemB || !itemA.isDetermined || !itemB.isDetermined) {
                    statusEl.textContent = '素材 A 或 B 不存在或未被确定发现。';
                    log(`[手动合成失败] 素材 A 或 B 不存在或未被确定发现。A:${nameA}(ID:${itemA?.id}), B:${nameB}(ID:${itemB?.id})`);
                    return;
                }

                log(`[手动合成] 尝试合成: ${nameA} + ${nameB} = ?`);
                statusEl.textContent = '正在调用API...';
                statusEl.style.color = '#007bff';
                
                try {
                    const resultName = await this.callSynthesisApi(nameA, nameB);
                    
                    if (resultName) {
                        resultEl.textContent = resultName;
                        resultEl.style.color = '#28a745';
                        
                        // 调用 addRecipe，isExploration=false, skipSave=false (非遍历、立即保存)
                        const result = await this.addRecipe(itemA.id, itemB.id, resultName, false, false); 
                        
                        if (result) {
                            statusEl.textContent = '合成配方添加成功！';
                            statusEl.style.color = '#28a745';
                        } else {
                            statusEl.textContent = '配方已存在，无需重复添加。';
                            statusEl.style.color = '#ffc107';
                        }
                    } else {
                        resultEl.textContent = '未知';
                        resultEl.style.color = '#dc3545';
                        statusEl.textContent = 'API调用失败，未获得合成结果。';
                        statusEl.style.color = '#dc3545';
                        log(`[手动合成失败] API未返回有效结果。`);
                    }
                    
                    // 清除输入
                    document.getElementById('material_a_name').value = '';
                    document.getElementById('material_b_name').value = '';

                } catch (e) {
                    log(`[手动合成失败] ${e.message}`);
                    statusEl.textContent = '合成失败，请检查日志。';
                    statusEl.style.color = '#dc3545';
                }

                this.renderStatus();
            }

            // G. 文件导入/导出 (JSON 保持不变)
            exportData() {
                // ... (保持不变) ...
                const data = {
                    items: Array.from(this.state.items.entries()), 
                    recipes: Array.from(this.state.recipes.entries()), 
                    max_positive_id: this.state.max_positive_id,
                    min_negative_id: this.state.min_negative_id,
                    exploration_depth: this.state.exploration_depth,
                    exploration_A_idx: this.state.exploration_A_idx,
                    exploration_B_idx: this.state.exploration_B_idx,
                    traversal_complete: this.state.traversal_complete,
                    recipeDisplayMode: this.recipeDisplayMode
                };
                const jsonStr = JSON.stringify(data, null, 2);
                
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `synthesis_state_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log("数据已导出为 JSON 文件 (下载完成)。");
            }

            importData() {
                // ... (保持不变) ...
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    log(`正在读取文件: ${file.name}...`);
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        const jsonStr = e.target.result;
                        try {
                            const data = JSON.parse(jsonStr);
                            
                            if (!data.items || !data.recipes) throw new Error("导入文件缺少关键的 items 或 recipes 字段。");

                            const newItems = new Map(data.items.map(([id, item]) => [Number(id), Object.assign(new Item(), item)]));
                            
                            this.state.items = newItems;
                            this.state.recipes = new Map(data.recipes); 
                            this.state.max_positive_id = data.max_positive_id;
                            this.state.min_negative_id = data.min_negative_id;
                            this.state.exploration_depth = data.exploration_depth;
                            this.state.exploration_A_idx = data.exploration_A_idx;
                            this.state.exploration_B_idx = data.exploration_B_idx;
                            this.state.traversal_complete = data.traversal_complete;
                            this.recipeDisplayMode = data.recipeDisplayMode !== undefined ? data.recipeDisplayMode : false;
                            
                            this.saveState();
                            this.renderStatus();
                            this._updateControlUI();
                            log("数据导入成功，State 已更新。");
                        } catch (e) {
                            log(`数据导入失败: 无效的文件内容或格式错误. ${e.message}`);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            // H. 新增配方 TXT 导出 (保持不变)
            exportRecipesAsText() {
                let textContent = '';
                const sortedRecipes = Array.from(this.state.recipes.entries()).sort(([keyA], [keyB]) => {
                    const [lidA, ridA, pidA] = JSON.parse(keyA);
                    const [lidB, ridB, pidB] = JSON.parse(keyB);
                    const pidCompare = customIdCompare(pidA, pidB);
                    if (pidCompare !== 0) return pidCompare;
                    return customIdCompare(lidA, lidB);
                });
                
                sortedRecipes.forEach(([key, isSimple]) => {
                    const [lid, rid, pid] = JSON.parse(key);
                    const nameA = this.getItemNameById(lid);
                    const nameB = this.getItemNameById(rid);
                    const nameC = this.getItemNameById(pid);
                    
                    if (!nameA.includes('ID:') && !nameB.includes('ID:') && !nameC.includes('ID:')) {
                        textContent += `${nameA} + ${nameB} = ${nameC}\n`;
                    }
                });

                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `synthesis_recipes_${new Date().toISOString().slice(0, 10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log("合成表已导出为 TXT 文件 (下载完成)。");
            }

            // I. 新增配方 TXT 导入 (保持不变)
            importRecipesFromText() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'text/plain';
                
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    log(`正在读取文件: ${file.name}...`);
                    const reader = new FileReader();
                    
                    reader.onload = async (e) => {
                        const textContent = e.target.result;
                        log("**************************************************");
                        log("⚠️ 警告：导入的数据未经验证，请勿信任其为最短路径。");
                        log("**************************************************");

                        const lines = textContent.split('\n');
                        const recipeRegex = /^\s*(.+?)\s*\+\s*(.+?)\s*=\s*(.+?)\s*$/;
                        let importedCount = 0;
                        let skippedCount = 0;

                        const recipesToProcess = [];
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            const match = line.match(recipeRegex);
                            if (match) {
                                const nameA = match[1].trim();
                                const nameB = match[2].trim();
                                const nameC = match[3].trim();

                                const itemA = this.getElementByName(nameA);
                                const itemB = this.getElementByName(nameB);
                                
                                if (itemA && itemB && itemA.isDetermined && itemB.isDetermined) {
                                    recipesToProcess.push({ idA: itemA.id, idB: itemB.id, nameC: nameC });
                                } else {
                                    skippedCount++;
                                }
                            } else {
                                skippedCount++;
                            }
                        }

                        log(`[导入] 开始处理 ${recipesToProcess.length} 条有效配方... (共跳过 ${skippedCount} 条)`);

                        for (let i = 0; i < recipesToProcess.length; i++) {
                            const { idA, idB, nameC } = recipesToProcess[i];
                            
                            // isExploration=false, skipSave=true (非遍历、批量导入模式)
                            await this.addRecipe(idA, idB, nameC, false, true); 
                            importedCount++;
                            
                            if (i % 50 === 0 || i === recipesToProcess.length - 1) {
                                this.renderStatus(true, false); 
                                await new Promise(resolve => setTimeout(resolve, 0)); 
                            }
                        }

                        this.saveState();
                        this.renderStatus();
                        log(`数据导入处理完成。成功导入 ${importedCount} 条配方。`);
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            // J. 新增清空本地数据功能
            clearLocalData() {
                if (confirm("确定要清空所有本地数据吗？此操作不可恢复！")) {
                    try {
                        localStorage.removeItem('synthesisAppState');
                        this.state = new State();
                        this.initialize();
                        this.renderStatus();
                        this._updateControlUI();
                        log("本地数据已清空，系统已重置。");
                    } catch (e) {
                        log(`清空本地数据失败: ${e.message}`);
                    }
                }
            }

            // K. 初始化 (保持不变)
            initialize() {
                let loadedSuccessfully = this.loadState();
                
                const baseElementsPresent = Array.from(this.state.items.values()).filter(item => item.depth === 0).length === this.state.elements.length;

                if (!loadedSuccessfully || !baseElementsPresent) {
                    log(loadedSuccessfully ? "警告: 发现本地存储状态不完整（缺少初始元素），将重置并初始化。" : "首次运行或本地存储状态无效，正在初始化...");
                    
                    this.state = new State(); 
                    
                    this.state.elements.forEach((name, index) => {
                        this.state.items.set(index, new Item(index, name, 0, 1));
                        this.state.max_positive_id = index;
                    });
                    
                    this.state.min_negative_id = -1;
                    this.saveState();
                    log(`系统 State 初始化成功，创建了 ${this.state.elements.length} 个初始元素。`);
                } else {
                    log("状态已从本地存储加载并验证。");
                }
                
                this._updateControlUI();
            }
            
            // L. 新增：渲染 Datalist 选项
            renderDatalist() {
                const datalist = document.getElementById('item_names_datalist');
                if (!datalist) return;

                // 筛选出所有确定状态的 Item (ID >= 0)
                const determinedItems = Array.from(this.state.items.values()).filter(item => item.isDetermined);
                
                // 按名称排序
                determinedItems.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

                // 生成 <option> 列表
                datalist.innerHTML = determinedItems.map(item => 
                    `<option value="${item.name}">`
                ).join('');
            }


            // M. UI 渲染 (应用新的统计可视化)
            renderStatus(skipScrollSave = false, skipTableContent = false) {
                // ... (状态和统计信息渲染保持不变) ...
                document.getElementById('max_id').textContent = this.state.max_positive_id;
                document.getElementById('min_id').textContent = this.state.min_negative_id;
                const exp_status = this.state.traversal_complete ? '完成' : '运行中';
                document.getElementById('exp_depth').textContent = `${this.state.exploration_depth} (A:${this.state.exploration_A_idx}, B:${this.state.exploration_B_idx}, ${exp_status})`;

                document.getElementById('current_depth').textContent = this.state.exploration_depth;
                const S_D = Array.from(this.state.items.values()).filter(item => item.isDetermined && item.depth <= this.state.exploration_depth);
                const progress = calculateProgress(S_D.length, this.state.exploration_A_idx, this.state.exploration_B_idx);
                if (!this.state.traversal_complete) {
                    document.getElementById('progress_text').textContent = `${progress.current} / ${progress.total} (${progress.percentage.toFixed(2)}%)`;
                    document.getElementById('progress_bar').value = progress.percentage;
                } else {
                    document.getElementById('progress_text').textContent = '100% (深度已完成)';
                    document.getElementById('progress_bar').value = 100;
                }

                const stats = calculateStatistics(this.state);
                const { depthVizHTML, widthVizHTML } = generateVisualizationHTML(stats);
                
                let statsHtml = `
                    <div class="stats-item"><strong>总Item数:</strong> <span>${stats.totalItems}</span></div>
                    <div class="stats-item"><strong>确定Item数:</strong> <span>${stats.determinedItems}</span></div>
                    <div class="stats-item"><strong>不确定Item数:</strong> <span>${stats.undeterminedItems}</span></div>
                    
                    <div class="stats-item"><strong>总Recipe数:</strong> <span>${stats.totalRecipes}</span></div>
                    <div class="stats-item"><strong>Simple Recipe数:</strong> <span>${stats.simpleRecipes}</span></div>
                    
                    <div class="depth-width-stats">
                        ${depthVizHTML}
                        ${widthVizHTML}
                    </div>
                `;
                document.getElementById('statistics_block').innerHTML = statsHtml;
                
                // 渲染 Datalist 必须在 skipTableContent 之外
                this.renderDatalist();

                if (skipTableContent) return; 

                const currentItemBody = document.getElementById('item_list')?.querySelector('.table-body');
                const currentRecipeBody = document.getElementById('recipe_list')?.querySelector('.table-body');
                if (currentItemBody && !skipScrollSave) scrollPositions.itemList = currentItemBody.scrollTop;
                if (currentRecipeBody && !skipScrollSave) scrollPositions.recipeList = currentRecipeBody.scrollTop;

                // 5. 渲染 Items (应用新的排序逻辑)
                let itemHeader = `
                    <div class="table-header item-header">
                        <span class="col-seq">No.</span>
                        <span class="col-id">ID<input id="filter-id" oninput="filterTable('item_list', 'id')" placeholder="过滤 ID" value="${filterValues.id}"></span>
                        <span class="col-depth">Depth<input id="filter-depth" oninput="filterTable('item_list', 'depth')" placeholder="过滤 D" value="${filterValues.depth}"></span>
                        <span class="col-width">Width<input id="filter-width" oninput="filterTable('item_list', 'width')" placeholder="过滤 W" value="${filterValues.width}"></span>
                        <span class="col-name">Name<input id="filter-name" oninput="filterTable('item_list', 'name')" placeholder="过滤 Name" value="${filterValues.name}"></span>
                    </div>
                    <div class="table-body item-body">
                `;
                let itemBody = '';
                Array.from(this.state.items.values()).sort((a, b) => customIdCompare(a.id, b.id)).forEach((item, index) => {
                    const status = item.isDetermined ? '确定' : '非确定';
                    itemBody += `
                        <div class="table-row">
                            <span class="col-seq">${index + 1}</span>
                            <span class="col-id">${item.id} (${status})</span>
                            <span class="col-depth">${item.depth}</span>
                            <span class="col-width">${item.width}</span>
                            <span class="col-name">${item.name}</span>
                        </div>
                    `;
                });
                itemBody += '</div>';
                document.getElementById('item_list').innerHTML = itemHeader + itemBody;
                
                // 6. 渲染 Recipes (应用新的排序逻辑)
                let recipeHeader, recipeBody;
                const sortedRecipes = Array.from(this.state.recipes.entries()).sort(([keyA], [keyB]) => {
                    const [lidA, ridA, pidA] = JSON.parse(keyA);
                    const [lidB, ridB, pidB] = JSON.parse(keyB);
                    
                    const pidCompare = customIdCompare(pidA, pidB);
                    if (pidCompare !== 0) return pidCompare;

                    return customIdCompare(lidA, lidB);
                });


                if (this.recipeDisplayMode) {
                    recipeHeader = `
                        <div class="table-header recipe-header">
                            <span class="col-seq">No.</span>
                            <span class="col-simple-list">合成配方<input id="filter-recipe_simple_list" oninput="filterTable('recipe_list', 'recipe_simple_list')" placeholder="过滤配方" value="${filterValues.recipe_simple_list}"></span>
                        </div>
                        <div class="table-body recipe-body simple-list-body">
                    `;
                    recipeBody = '';
                    sortedRecipes.forEach(([key, isSimple], index) => {
                        const [lid, rid, pid] = JSON.parse(key);
                        const nameA = this.getItemNameById(lid);
                        const nameB = this.getItemNameById(rid);
                        const nameC = this.getItemNameById(pid);
                        recipeBody += `<div class="table-row">
                            <span class="col-seq">${index + 1}</span>
                            <span class="col-simple-list">${nameA} + ${nameB} = ${nameC}</span>
                        </div>`;
                    });
                    recipeBody += '</div>';
                } else {
                    recipeHeader = `
                        <div class="table-header recipe-header">
                            <span class="col-seq">No.</span>
                            <span class="col-lid">LID<input id="filter-lid" oninput="filterTable('recipe_list', 'lid')" placeholder="过滤 LID" value="${filterValues.lid}"></span>
                            <span class="col-rid">RID<input id="filter-rid" oninput="filterTable('recipe_list', 'rid')" placeholder="过滤 RID" value="${filterValues.rid}"></span>
                            <span class="col-pid">PID<input id="filter-pid" oninput="filterTable('recipe_list', 'pid')" placeholder="过滤 PID" value="${filterValues.pid}"></span>
                            <span class="col-simple">Simple<input id="filter-simple" oninput="filterTable('recipe_list', 'simple')" placeholder="T/F" value="${filterValues.simple}"></span>
                        </div>
                        <div class="table-body recipe-body">
                    `;
                    recipeBody = '';
                    sortedRecipes.forEach(([key, isSimple], index) => {
                        const [lid, rid, pid] = JSON.parse(key);
                        recipeBody += `
                            <div class="table-row">
                                <span class="col-seq">${index + 1}</span>
                                <span class="col-lid">${lid}</span>
                                <span class="col-rid">${rid}</span>
                                <span class="col-pid">${pid}</span>
                                <span class="col-simple">${isSimple ? 'True' : 'False'}</span>
                            </div>
                        `;
                    });
                    recipeBody += '</div>';
                }
                document.getElementById('recipe_list').innerHTML = recipeHeader + recipeBody;

                // 7. 恢复滚动位置 (略)
                document.getElementById('item_list').querySelector('.table-body').scrollTop = scrollPositions.itemList;
                document.getElementById('recipe_list').querySelector('.table-body').scrollTop = scrollPositions.recipeList;
                
                // 8. 重新应用筛选 (略)
                ['id', 'depth', 'width', 'name'].forEach(f => { if (filterValues[f]) filterTable('item_list', f); });
                
                if (this.recipeDisplayMode) {
                    if (filterValues['recipe_simple_list']) filterTable('recipe_list', 'recipe_simple_list');
                } else {
                    ['lid', 'rid', 'pid', 'simple'].forEach(f => { if (filterValues[f]) filterTable('recipe_list', f); });
                }
            }
        }

        const app = new SynthesisApp();
        
        // ----------------------------------------------------
        // I. 自动初始化
        // ----------------------------------------------------
        window.onload = () => {
            log("页面加载完成，开始自动初始化...");
            app.initialize();
            app.renderStatus();
        };
    </script>
</body>
</html>
