<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂêàÊàêÊï∞ÊçÆÂèØËßÜÂåñ</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3a86ff;
            --accent-color: #ff6b6b;
            --success-color: #06d6a0;
            --text-color: #2b2d42;
            --light-text: #8d99ae;
            --bg-color: #f8f9fa;
            --card-bg: white;
            --border-radius: 16px;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body { 
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            padding: 20px; 
            background-color: var(--bg-color); 
            color: var(--text-color);
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1400px; 
            margin: auto; 
            background: var(--card-bg); 
            padding: 30px; 
            border-radius: var(--border-radius); 
            box-shadow: var(--shadow); 
        }

        h1 { 
            color: var(--primary-color); 
            border-bottom: 3px solid var(--primary-color); 
            padding-bottom: 12px; 
            margin-bottom: 25px; 
            font-weight: 600; 
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        h1:before {
            content: "üìä";
            font-size: 1.5rem;
        }
        
        h2 { 
            color: var(--text-color); 
            margin-top: 25px; 
            border-left: 5px solid var(--accent-color); 
            padding-left: 15px; 
            font-weight: 600; 
            font-size: 1.4rem;
            margin-bottom: 15px;
        }
        
        .chart-container { 
            border: 1px solid #e9ecef; 
            border-radius: 12px; 
            margin-top: 15px;
            background: #fafafa;
            overflow: hidden; 
            position: relative;
            transition: var(--transition);
        }
        
        .chart-container:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .controls { 
            margin-bottom: 20px; 
            display: flex; 
            align-items: center; 
            flex-wrap: wrap; 
            gap: 12px; 
            padding: 12px 0; 
        }
        
        .controls input[type="file"], 
        .controls button, 
        .controls input[type="text"], 
        .controls input[type="number"] { 
            padding: 12px 16px; 
            border-radius: 8px; 
            border: 1px solid #e1e5e9; 
            font-size: 14px; 
            transition: var(--transition);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.03);
            min-height: 44px;
            background: white;
        }
        
        .controls input[type="text"], 
        .controls input[type="number"] {
            width: 100%;
        }
        
        .controls button { 
            background-color: var(--primary-color); 
            color: white; 
            cursor: pointer; 
            border: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        
        .controls button:hover, 
        .controls button:active { 
            background-color: var(--secondary-color); 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
            transform: translateY(-2px);
        }
        
        .controls button.import-btn {
            background-color: var(--success-color);
        }
        
        .controls button.clear-btn {
            background-color: var(--accent-color);
        }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .tabs {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            margin-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 5px;
        }
        
        .tabs::-webkit-scrollbar {
            display: none;
        }
        
        .tabs button {
            padding: 12px 20px;
            border: none;
            cursor: pointer;
            background-color: transparent;
            border-radius: 8px;
            font-weight: 500;
            flex-shrink: 0;
            margin-right: 5px;
            transition: var(--transition);
            color: var(--light-text);
        }
        
        .tabs button.active {
            background-color: white;
            color: var(--primary-color);
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        #status_message { 
            color: var(--success-color); 
            font-weight: 500; 
            margin-left: 10px; 
            word-break: break-word;
            flex: 1;
            min-width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #log_area {
            min-height: 20px; 
            padding: 15px; 
            border: 1px solid #e9ecef; 
            border-radius: 10px; 
            margin-bottom: 20px; 
            background: #fdfdff; 
            font-size: 13px; 
            color: var(--light-text); 
            overflow-y: auto; 
            max-height: 120px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);
        }
        
        #log_area p {
             margin: 0;
             padding: 5px 0;
             border-bottom: 1px dashed #eee;
        }
        
        #log_area p:last-child {
             border-bottom: none;
        }

        #rectangular_tree_container_wrapper {
            height: 500px;
            overflow: hidden; 
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            position: relative;
        }

        #rectangular_tree_container_wrapper.is-dragging {
            cursor: grabbing;
        }

        #rectangular_tree_container {
            height: 100%;
            display: flex; 
            align-items: flex-start; 
            flex-wrap: nowrap;
            transform-origin: 0 0; 
            transition: transform 0.1s ease-out; 
            min-width: 100%; 
            position: relative;
        }
        
        .icicle-root {
            height: 100%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            position: absolute;
            top: 0;
        }

        .icicle-node-container {
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 2px;
            margin-top: -1px; 
        }

        .icicle-node-label {
            height: 35px;
            line-height: 35px;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: #fff;
            box-sizing: border-box;
            overflow: hidden;
            white-space: nowrap;
            cursor: pointer;
            width: 100%; 
            margin: 0; 
            padding: 0 8px;
            border-radius: 4px; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), inset 0 0 8px rgba(255, 255, 255, 0.3);
            transition: var(--transition);
            border: 1px solid rgba(255, 255, 255, 0.3); 
        }
        
        .icicle-node-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15), inset 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .icicle-children-container {
            display: flex;
            flex-direction: row;
            width: 100%; 
            flex-grow: 1; 
        }
        
        #dag_graph_container {
            height: 500px; 
            position: relative;
        }
        
        .chart-wrapper {
            position: relative;
        }
        
        .fullscreen-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.9);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: var(--transition);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .fullscreen-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
            white-space: nowrap; 
            margin: 5px 0;
        }

        .toggle-switch input {
            display: none;
        }

        .slider {
            width: 45px;
            height: 24px;
            background-color: #e1e5e9;
            border-radius: 12px;
            position: relative;
            margin-left: 10px;
            margin-right: 8px;
            transition: var(--transition);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .slider:before {
            content: "";
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: white;
            top: 3px;
            left: 3px;
            transition: var(--transition);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(21px);
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        
        .filter-group span {
            color: var(--light-text);
            font-size: 14px;
        }
        
        .search-container {
            flex: 1;
            min-width: 200px;
        }
        
        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            width: 100%;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 20px;
                border-radius: 12px;
            }
            
            h1 {
                font-size: 1.5rem;
                padding-bottom: 8px;
            }
            
            h2 {
                font-size: 1.3rem;
                margin-top: 20px;
                padding-left: 12px;
            }
            
            .controls {
                gap: 10px;
                padding: 10px 0;
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls > * {
                width: 100% !important;
                margin-bottom: 5px;
            }
            
            .controls input[type="file"],
            .controls button,
            .controls input[type="text"],
            .controls input[type="number"] {
                padding: 14px;
                font-size: 16px;
                width: 100% !important;
            }
            
            .controls button {
                padding: 14px 18px;
            }
            
            .tabs {
                margin-bottom: 15px;
            }
            
            .tabs button {
                padding: 10px 16px;
                font-size: 14px;
            }
            
            #status_message {
                margin-left: 0;
                margin-top: 10px;
                text-align: center;
                order: 10;
            }
            
            #rectangular_tree_container_wrapper,
            #dag_graph_container {
                height: 400px;
            }
            
            .icicle-node-label {
                font-size: 11px;
                height: 30px;
                line-height: 30px;
            }
            
            .toggle-switch {
                font-size: 14px;
                margin-top: 5px;
                margin-bottom: 5px;
            }
            
            #log_area {
                max-height: 100px;
                font-size: 12px;
            }
            
            .filter-group {
                width: 100%;
                justify-content: space-between;
            }
            
            .filter-group span {
                width: 60px;
            }
            
            .filter-group input[type="number"] {
                width: calc(50% - 35px) !important;
            }
            
            .search-container {
                width: 100%;
            }
            
            .input-group {
                gap: 8px;
            }
            
            .fullscreen-btn {
                top: 10px;
                right: 10px;
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 1.4rem;
            }
            
            h2 {
                font-size: 1.2rem;
            }
            
            #rectangular_tree_container_wrapper,
            #dag_graph_container {
                height: 350px;
            }
            
            .icicle-node-label {
                font-size: 10px;
                height: 28px;
                line-height: 28px;
            }
            
            .toggle-switch {
                font-size: 13px;
            }
            
            .controls {
                gap: 8px;
            }
        }

        @media (max-width: 768px) {
            input[type="text"],
            input[type="number"] {
                font-size: 16px !important;
            }
        }

        .fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 9999;
            background: white;
            padding: 15px;
        }

        .fullscreen .chart-container {
            height: calc(100% - 60px) !important;
        }

        .icicle-node-label {
            will-change: transform;
        }

        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .vis-network {
            transform: translateZ(0);
        }
        
        .card {
            background: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }
        
        .stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .stat-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: var(--shadow);
            flex: 1;
            min-width: 150px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: var(--light-text);
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>ÂêàÊàêÊï∞ÊçÆÂèØËßÜÂåñÂàÜÊûêÂπ≥Âè∞</h1>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="total-items">0</div>
                <div class="stat-label">ÊÄªÂÖÉÁ¥†Êï∞</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="total-recipes">0</div>
                <div class="stat-label">ÂêàÊàêÈÖçÊñπÊï∞</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="max-depth">0</div>
                <div class="stat-label">ÊúÄÂ§ßÊ∑±Â∫¶</div>
            </div>
        </div>

        <div class="card">
            <div class="controls">
                <input type="file" id="json_file_input" accept="application/json">
                <button class="import-btn" onclick="app.importData()">
                    <span>üìÅ</span> ÂØºÂÖ• JSON Êï∞ÊçÆ
                </button>
                <button class="clear-btn" onclick="app.clearStorageData()">
                    <span>üóëÔ∏è</span> Ê∏ÖÈô§Â≠òÂÇ®Êï∞ÊçÆ
                </button>
                <span id="status_message">
                    <span>‚úÖ</span> ÂáÜÂ§áÂ∞±Áª™„ÄÇ
                </span>
            </div>
            
            <div id="log_area">
                <p>Êó•Âøó/Áä∂ÊÄÅ‰ø°ÊÅØ:</p>
            </div>
        </div>

        <div class="tabs">
            <button id="tab1-btn" class="active" onclick="app.showTab(1)">Áü©ÂΩ¢ÂÜ∞Êü±Âõæ</button>
            <button id="tab2-btn" onclick="app.showTab(2)">ÊúâÂêëÊó†ÁéØÂõæ</button>
        </div>

        <div id="tab1" class="tab-content active">
            <h2>Áü©ÂΩ¢ÂÜ∞Êü±ÂõæÂàÜÊûê</h2>
            <p class="description">ÂèØËßÜÂåñÂÖÉÁ¥†ÁöÑÂ±ÇÁ∫ßÁªìÊûÑÂíåÂêàÊàêË∑ØÂæÑÔºåÊîØÊåÅ‰∫§‰∫íÂºèÊé¢Á¥¢„ÄÇ</p>
            
            <div class="card">
                <div class="controls">
                    <div class="input-group">
                        <div class="search-container">
                            <input type="text" id="icicle_search_input" placeholder="ËæìÂÖ•ÂÖÉÁ¥†ÂêçÁß∞ÂÆûÊó∂ÊêúÁ¥¢" oninput="app.debouncedRenderRectangularTree()" list="item_names_datalist">
                        </div>
                        
                        <label class="toggle-switch">
                            <input type="checkbox" id="search_only_roots" checked onchange="app.debouncedRenderRectangularTree()">
                            <span class="slider"></span>
                            Âè™ÊêúÁ¥¢Ê†πËäÇÁÇπ
                        </label>
                        
                        <div class="filter-group">
                            <span>Ê∑±Â∫¶:</span>
                            <input type="number" id="min_depth_filter_icicle" placeholder="ÊúÄÂ∞è" oninput="app.debouncedRenderRectangularTree()">
                            <input type="number" id="max_depth_filter_icicle" placeholder="ÊúÄÂ§ß" oninput="app.debouncedRenderRectangularTree()">
                        </div>
                        
                        <div class="filter-group">
                            <span>ÂÆΩÂ∫¶:</span>
                            <input type="number" id="min_width_filter_icicle" placeholder="ÊúÄÂ∞è" oninput="app.debouncedRenderRectangularTree()">
                            <input type="number" id="max_width_filter_icicle" placeholder="ÊúÄÂ§ß" oninput="app.debouncedRenderRectangularTree()">
                        </div>
                    </div>
                </div>
                
                <div class="chart-wrapper">
                    <div id="rectangular_tree_container_wrapper" class="chart-container">
                         <div id="rectangular_tree_container" style="transform: translate(0px, 0px) scale(1);">
                            <p style="padding: 20px; text-align: center; color: var(--light-text);">ËØ∑ÂØºÂÖ•Êï∞ÊçÆÂπ∂Á≠âÂæÖÂõæË°®Ê∏≤Êüì„ÄÇ</p>
                         </div>
                    </div>
                    <button class="fullscreen-btn" onclick="app.toggleFullscreen('rectangular_tree_container_wrapper')">
                        <span>‚õ∂</span> ÂÖ®Â±è
                    </button>
                </div>
            </div>
        </div>

        <div id="tab2" class="tab-content">
            <h2>ÊúâÂêëÊó†ÁéØÂõæÂàÜÊûê</h2>
            <p class="description">Êé¢Á¥¢ÂÖÉÁ¥†‰πãÈó¥ÁöÑÂêàÊàêÂÖ≥Á≥ªÔºåÁÇπÂáªËäÇÁÇπÂ±ïÂºÄ/Êî∂Ëµ∑ÂÖ∂ÈÇªÂ±Ö„ÄÇ</p>
            
            <div class="card">
                <div class="controls">
                    <div class="input-group">
                        <div class="search-container">
                            <input type="text" id="dag_search_input" placeholder="ËæìÂÖ•Ë¶ÅÊêúÁ¥¢ÁöÑÂÖÉÁ¥†ÂêçÁß∞" list="item_names_datalist" oninput="app.debouncedInitialRenderDAG()">
                        </div>
                        
                        <label class="toggle-switch">
                            <input type="checkbox" id="non_simple_toggle" onchange="app.debouncedUpdateGraph()">
                            <span class="slider"></span>
                            ÊòæÁ§∫ÈùûÊúÄÁÆÄË∑ØÂæÑ
                        </label>
                        
                        <label class="toggle-switch">
                            <input type="checkbox" id="expand_only_parents" checked onchange="app.debouncedUpdateGraph()">
                            <span class="slider"></span>
                            Â±ïÂºÄÁ¥†Êùê
                        </label>

                        <label class="toggle-switch">
                            <input type="checkbox" id="expand_children_and_peers" onchange="app.debouncedUpdateGraph()">
                            <span class="slider"></span>
                            Â±ïÂºÄ‰∫ßÁâ©
                        </label>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="input-group">
                        <div class="filter-group">
                            <span>Ê∑±Â∫¶:</span>
                            <input type="number" id="min_depth_filter" placeholder="ÊúÄÂ∞è" oninput="app.debouncedUpdateGraph()">
                            <input type="number" id="max_depth_filter" placeholder="ÊúÄÂ§ß" oninput="app.debouncedUpdateGraph()">
                        </div>
                        
                        <div class="filter-group">
                            <span>ÂÆΩÂ∫¶:</span>
                            <input type="number" id="min_width_filter" placeholder="ÊúÄÂ∞è" oninput="app.debouncedUpdateGraph()">
                            <input type="number" id="max_width_filter" placeholder="ÊúÄÂ§ß" oninput="app.debouncedUpdateGraph()">
                        </div>
                    </div>
                </div>

                <div class="chart-wrapper">
                    <div id="dag_graph_container" class="chart-container">
                         <p style="padding: 20px; text-align: center; color: var(--light-text);">ËØ∑Âú®‰∏äÊñπËæìÂÖ•Ê°Ü‰∏≠ËæìÂÖ•ÂÖÉÁ¥†ÂêçÁß∞ËøõË°åÊêúÁ¥¢„ÄÇ</p>
                    </div>
                    <button class="fullscreen-btn" onclick="app.toggleFullscreen('dag_graph_container')">
                        <span>‚õ∂</span> ÂÖ®Â±è
                    </button>
                </div>
            </div>
            <datalist id="item_names_datalist"></datalist>
        </div>
        
    </div>

    <script>
        class Item {
            constructor(id, name, depth = -1, width = 1) {
                this.id = id; this.name = name; this.depth = depth; this.width = width;
            }
            get isDetermined() { return this.id >= 0; }
        }

        class Recipe {
            constructor(idA, idB, idC, simple = false) {
                const [lid, rid] = idA <= idB ? [idA, idB] : [idB, idA];
                this.id = [lid, rid, idC]; 
                this.simple = simple; 
            }
            get sourceA() { return this.id[0]; }
            get sourceB() { return this.id[1]; }
            get product() { return this.id[2]; }
        }

        class VisualizationApp {
            constructor() {
                this.items = new Map();     
                this.recipes = new Map();   
                this.initialElements = ['Èáë', 'Êú®', 'Ê∞¥', 'ÁÅ´', 'Âúü'];
                this.hasData = false;
                this.recipesByProduct = new Map();  
                this.recipesBySource = new Map();   
                this.itemNames = new Map();         
                
                this.currentTab = 1;
                this.network = null;    
                this.dagNodes = null;   
                this.dagEdges = null;   

                this.expandedNodeIds = new Set(); 
                
                this.ICICLE_BASE_UNIT_WIDTH = 35; 
                this.ICICLE_NODE_MARGIN = 2;      
                
                this.icicleZoomLevel = 1.0;
                this.icicleMaxDepth = 1; 
                this.iciclePanX = 0;
                this.iciclePanY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.debounceTimers = {};
                
                this.renderScheduled = false;
                this.virtualScrollEnabled = true;
                this.visibleRoots = [];
                this.allRoots = [];
                this.virtualScrollOffset = 0;
                this.visibleRange = { start: 0, end: 0 };
                this.virtualScrollRafId = null;
                
                this.searchOnlyRoots = true;
                
                this.icicleCache = new Map();
                
                this.icicleBounds = {
                    minX: 0,
                    maxX: 0,
                    minY: 0,
                    maxY: 0
                };
            }

            debounce(func, wait, immediate) {
                return function() {
                    const context = this;
                    const args = arguments;
                    const later = function() {
                        this.debounceTimers[func] = null;
                        if (!immediate) func.apply(context, args);
                    }.bind(this);
                    const callNow = immediate && !this.debounceTimers[func];
                    clearTimeout(this.debounceTimers[func]);
                    this.debounceTimers[func] = setTimeout(later, wait);
                    if (callNow) func.apply(context, args);
                }.bind(this);
            }

            initDebounceFunctions() {
                this.debouncedRenderRectangularTree = this.debounce(this.renderRectangularTree, 300);
                this.debouncedInitialRenderDAG = this.debounce(this.initialRenderDAG, 300);
                this.debouncedUpdateGraph = this.debounce(this._updateGraphFromExpandedSet, 300);
            }

            logMessage(message, isError = false) {
                const logArea = document.getElementById('log_area');
                const statusEl = document.getElementById('status_message');
                
                statusEl.innerHTML = isError ? 
                    `<span style="color: var(--accent-color)">‚ö†Ô∏è</span> ${message}` :
                    `<span style="color: var(--success-color)">‚úÖ</span> ${message}`;

                const now = new Date();
                const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
                
                const logEntry = document.createElement('p');
                logEntry.style.color = isError ? 'var(--accent-color)' : 'var(--light-text)';
                logEntry.innerHTML = `[${timeString}] ${message}`;

                logArea.appendChild(logEntry);

                while (logArea.children.length > 20) {
                    logArea.removeChild(logArea.firstElementChild);
                }
                
                logArea.scrollTop = logArea.scrollHeight;
            }

            updateStats() {
                if (!this.hasData) return;
                
                const totalItems = Array.from(this.items.values()).filter(item => item.isDetermined).length;
                const totalRecipes = this.recipes.size;
                const maxDepth = this.icicleMaxDepth;
                
                document.getElementById('total-items').textContent = totalItems;
                document.getElementById('total-recipes').textContent = totalRecipes;
                document.getElementById('max-depth').textContent = maxDepth;
            }

            loadInitialData() {
                const storedData = localStorage.getItem('synthesis_data');
                if (storedData) {
                    try {
                        const importedData = JSON.parse(storedData);
                        this._processData(importedData, 'Êï∞ÊçÆÂ∑≤‰ªéÊú¨Âú∞Â≠òÂÇ®Âä†ËΩΩ„ÄÇ');
                        return;
                    } catch (e) {
                        this.logMessage("Âä†ËΩΩÊú¨Âú∞Êï∞ÊçÆÂ§±Ë¥•„ÄÇËØ∑ÂØºÂÖ•Êñ∞ÁöÑ JSON Êñá‰ª∂„ÄÇ", true);
                    }
                }
                this.logMessage('ËØ∑ÂØºÂÖ• JSON Êï∞ÊçÆ„ÄÇ', false);
            }

            saveDataToStorage(data) {
                try {
                    localStorage.setItem('synthesis_data', JSON.stringify(data));
                    this.logMessage("Êï∞ÊçÆÂ∑≤Ëá™Âä®‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®„ÄÇ", false);
                } catch (e) {
                    this.logMessage("‰øùÂ≠òÊï∞ÊçÆÂà∞Êú¨Âú∞Â≠òÂÇ®Â§±Ë¥•„ÄÇ", true);
                }
            }

            clearStorageData() {
                localStorage.removeItem('synthesis_data');
                this.hasData = false;
                this.logMessage('Â∑≤Ê∏ÖÈô§Êú¨Âú∞Â≠òÂÇ®ÁöÑÊï∞ÊçÆ„ÄÇËØ∑ÈáçÊñ∞ÂØºÂÖ•Êñá‰ª∂„ÄÇ', true);
                document.getElementById('rectangular_tree_container').innerHTML = '<p style="padding: 20px; text-align: center; color: var(--light-text);">ËØ∑ÂØºÂÖ•Êï∞ÊçÆÂπ∂Á≠âÂæÖÂõæË°®Ê∏≤Êüì„ÄÇ</p>';
                document.getElementById('dag_graph_container').innerHTML = '<p style="padding: 20px; text-align: center; color: var(--light-text);">ËØ∑Âú®‰∏äÊñπËæìÂÖ•Ê°Ü‰∏≠ËæìÂÖ•ÂÖÉÁ¥†ÂêçÁß∞ËøõË°åÊêúÁ¥¢„ÄÇ</p>';
                this.icicleZoomLevel = 1.0;
                this.iciclePanX = 0;
                this.iciclePanY = 0;
                this._applyIcicleTransform();
                this.icicleCache.clear();
                
                document.getElementById('total-items').textContent = '0';
                document.getElementById('total-recipes').textContent = '0';
                document.getElementById('max-depth').textContent = '0';
            }

            importData() {
                const input = document.getElementById('json_file_input');
                const file = input.files[0];
                if (!file) {
                    this.logMessage('ËØ∑ÈÄâÊã©‰∏Ä‰∏™ JSON Êñá‰ª∂„ÄÇ', true);
                    return;
                }

                this.logMessage('Ê≠£Âú®ËØªÂèñÊñá‰ª∂...');
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    await new Promise(resolve => setTimeout(resolve, 0)); 
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!importedData.items || !importedData.recipes) {
                            throw new Error("Êñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°ÆÔºåÁº∫Â∞ë items Êàñ recipes Â≠óÊÆµ„ÄÇ");
                        }
                        
                        this._processData(importedData, `Êï∞ÊçÆÂØºÂÖ•ÊàêÂäüÔºÅÊÄªItemÊï∞: ${importedData.items.length}„ÄÇ`);
                        this.saveDataToStorage(importedData);

                    } catch (error) {
                        this.logMessage(`Êï∞ÊçÆÂØºÂÖ•Â§±Ë¥•: ${error.message}`, true);
                        this.hasData = false;
                    }
                };
                reader.readAsText(file);
            }

            _processData(importedData, successMessage) {
                const statusEl = document.getElementById('status_message');
                statusEl.innerHTML = '<div class="loading"></div>Â§ÑÁêÜÊï∞ÊçÆ‰∏≠...';
                
                setTimeout(() => {
                    this.items = new Map();
                    this.recipes = new Map(importedData.recipes);
                    
                    let maxDepth = 1;
                    importedData.items.forEach(([id, itemData]) => {
                        const item = Object.assign(new Item(), itemData);
                        this.items.set(item.id, item);
                        if (item.isDetermined) {
                            this.itemNames.set(item.name, item);
                            if (item.depth > maxDepth) maxDepth = item.depth;
                        }
                    });
                    this.icicleMaxDepth = maxDepth; 

                    this.preprocessRecipes();
                    this.hasData = true;

                    this.logMessage(successMessage, false);
                    this.initSelectorsAndGraphs();
                    this.updateStats();
                    
                    statusEl.innerHTML = `<span style="color: var(--success-color)">‚úÖ</span> ${successMessage}`;
                    
                    this.icicleCache.clear();
                }, 10);
            }

            preprocessRecipes() {
                this.recipesByProduct.clear();
                this.recipesBySource.clear();

                this.recipes.forEach((isSimple, key) => {
                    const [lid, rid, pid] = JSON.parse(key);
                    const recipe = new Recipe(lid, rid, pid, isSimple);

                    if (!this.recipesByProduct.has(pid)) this.recipesByProduct.set(pid, []);
                    this.recipesByProduct.get(pid).push(recipe);

                    if (!this.recipesBySource.has(lid)) this.recipesBySource.set(lid, []);
                    this.recipesBySource.get(lid).push(recipe);
                    
                    if (lid !== rid) {
                        if (!this.recipesBySource.has(rid)) this.recipesBySource.set(rid, []);
                        this.recipesBySource.get(rid).push(recipe);
                    }
                });
            }

            getItemById(id) {
                return this.items.get(id);
            }

            getItemByName(name) {
                return this.itemNames.get(name);
            }

            initSelectorsAndGraphs() {
                this.initDebounceFunctions();
                this.renderDatalist();
                this.renderRectangularTree(); 
                this.showTab(this.currentTab);
            }

            showTab(tabNumber) {
                document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.tabs button').forEach(el => el.classList.remove('active'));

                document.getElementById(`tab${tabNumber}`).classList.add('active');
                document.getElementById(`tab${tabNumber}-btn`).classList.add('active');
                this.currentTab = tabNumber;
                
                if (tabNumber === 1 && this.hasData) {
                    this.renderRectangularTree();
                }
            }
            
            renderDatalist() {
                const datalist = document.getElementById('item_names_datalist');
                const determinedItems = Array.from(this.items.values()).filter(item => item.isDetermined);
                determinedItems.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
                datalist.innerHTML = determinedItems.map(item => `<option value="${item.name}">`).join('');
            }

            setupIcicleZoom() {
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                wrapper.addEventListener('mousedown', (e) => {
                    if (this.currentTab !== 1 || e.button !== 0) return; 
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    wrapper.classList.add('is-dragging');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging || this.currentTab !== 1) return;
                    
                    const dx = e.clientX - this.lastMouseX;
                    const dy = e.clientY - this.lastMouseY;
                    
                    this.iciclePanX += dx / this.icicleZoomLevel;
                    this.iciclePanY += dy / this.icicleZoomLevel;

                    this._constrainIcicleTransform();
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;

                    this._applyIcicleTransform();
                    
                    if (this.virtualScrollEnabled) {
                        this.scheduleVirtualScrollUpdate();
                    }
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    wrapper.classList.remove('is-dragging');
                });

                wrapper.addEventListener('touchstart', (e) => {
                    if (this.currentTab !== 1 || e.touches.length !== 1) return;
                    this.isDragging = true;
                    const touch = e.touches[0];
                    this.lastMouseX = touch.clientX;
                    this.lastMouseY = touch.clientY;
                    wrapper.classList.add('is-dragging');
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (!this.isDragging || this.currentTab !== 1 || e.touches.length !== 1) return;
                    const touch = e.touches[0];
                    
                    const dx = touch.clientX - this.lastMouseX;
                    const dy = touch.clientY - this.lastMouseY;
                    
                    this.iciclePanX += dx / this.icicleZoomLevel;
                    this.iciclePanY += dy / this.icicleZoomLevel;

                    this._constrainIcicleTransform();
                    
                    this.lastMouseX = touch.clientX;
                    this.lastMouseY = touch.clientY;

                    this._applyIcicleTransform();
                    
                    if (this.virtualScrollEnabled) {
                        this.scheduleVirtualScrollUpdate();
                    }
                    
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchend', () => {
                    this.isDragging = false;
                    wrapper.classList.remove('is-dragging');
                });

                let initialDistance = null;
                
                wrapper.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        initialDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        e.preventDefault();
                    }
                }, { passive: false });

                wrapper.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && initialDistance !== null) {
                        const currentDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        
                        const scaleFactor = currentDistance / initialDistance;
                        const oldZoom = this.icicleZoomLevel;
                        this.icicleZoomLevel = Math.max(0.2, Math.min(4.0, oldZoom * scaleFactor));
                        
                        const rect = wrapper.getBoundingClientRect();
                        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                        
                        const unscaledCenterX = (centerX / oldZoom) - this.iciclePanX;
                        const unscaledCenterY = (centerY / oldZoom) - this.iciclePanY;
                        
                        this.iciclePanX = (centerX / this.icicleZoomLevel) - unscaledCenterX;
                        this.iciclePanY = (centerY / this.icicleZoomLevel) - unscaledCenterY;
                        
                        this._constrainIcicleTransform();
                        
                        this._applyIcicleTransform();
                        
                        if (this.virtualScrollEnabled) {
                            this.scheduleVirtualScrollUpdate();
                        }
                        
                        initialDistance = currentDistance;
                        e.preventDefault();
                    }
                }, { passive: false });

                wrapper.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        initialDistance = null;
                    }
                });

                wrapper.addEventListener('wheel', (e) => {
                    if (!this.hasData || this.currentTab !== 1) return;
                    e.preventDefault(); 

                    const scaleFactor = 1.1; 
                    const oldZoom = this.icicleZoomLevel;
                    
                    if (e.deltaY < 0) {
                        this.icicleZoomLevel = Math.min(4.0, oldZoom * scaleFactor);
                    } else {
                        this.icicleZoomLevel = Math.max(0.2, oldZoom / scaleFactor);
                    }
                    
                    const rect = wrapper.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const unscaledMouseX = (mouseX / oldZoom) - (this.iciclePanX);
                    const unscaledMouseY = (mouseY / oldZoom) - (this.iciclePanY);

                    this.iciclePanX = (mouseX / this.icicleZoomLevel) - unscaledMouseX;
                    this.iciclePanY = (mouseY / this.icicleZoomLevel) - unscaledMouseY;
                    
                    this._constrainIcicleTransform();
                    
                    this._applyIcicleTransform();
                    
                    if (this.virtualScrollEnabled) {
                        this.scheduleVirtualScrollUpdate();
                    }
                }, { passive: false });
            }
            
            _applyIcicleTransform() {
                const container = document.getElementById('rectangular_tree_container');
                container.style.transform = `translate(${this.iciclePanX}px, ${this.iciclePanY}px) scale(${this.icicleZoomLevel})`;
            }

            _constrainIcicleTransform() {
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                const container = document.getElementById('rectangular_tree_container');
                
                if (!wrapper || !container) return;
                
                const wrapperWidth = wrapper.clientWidth;
                const wrapperHeight = wrapper.clientHeight;
                
                const containerWidth = container.offsetWidth * this.icicleZoomLevel;
                const containerHeight = container.offsetHeight * this.icicleZoomLevel;
                
                const minX = Math.min(0, wrapperWidth - containerWidth);
                const maxX = 0;
                const minY = Math.min(0, wrapperHeight - containerHeight);
                const maxY = 0;
                
                this.iciclePanX = Math.max(minX, Math.min(maxX, this.iciclePanX));
                this.iciclePanY = Math.max(minY, Math.min(maxY, this.iciclePanY));
                
                this.icicleBounds = {
                    minX, maxX, minY, maxY
                };
            }

            scheduleVirtualScrollUpdate() {
                if (this.virtualScrollRafId) {
                    cancelAnimationFrame(this.virtualScrollRafId);
                }
                this.virtualScrollRafId = requestAnimationFrame(() => {
                    this.updateVirtualScroll();
                });
            }

            _getDepthColor(depth, isHighlight = false) {
                const maxDepth = this.icicleMaxDepth || 10; 
                
                let hue; 
                let saturation;
                let lightness;
                let opacity = 0.95;
                
                if (depth === 0) {
                    hue = 85; 
                    saturation = 75;
                    lightness = 55;
                } else {
                    hue = 150; 
                    saturation = 65 - (depth / maxDepth) * 15;
                    lightness = 70 - (depth / maxDepth) * 20;
                }

                if (isHighlight) {
                    hue = 50; 
                    saturation = 90;
                    lightness = 60;
                    opacity = 1.0;
                }

                return `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`;
            }

            getIcicleDecomposition(itemId) {
                if (this.icicleCache.has(itemId)) {
                    return this.icicleCache.get(itemId);
                }

                const item = this.getItemById(itemId);
                if (!item || !item.isDetermined) return null;

                const node = {
                    id: item.id,
                    name: item.name,
                    depth: item.depth,
                    width: item.width,
                    children: []
                };

                if (item.depth === 0) {
                    this.icicleCache.set(itemId, node);
                    return node;
                }

                const simpleRecipes = (this.recipesByProduct.get(itemId) || [])
                    .filter(recipe => recipe.simple === true)
                    .filter(recipe => this.getItemById(recipe.sourceA)?.isDetermined && this.getItemById(recipe.sourceB)?.isDetermined);

                if (simpleRecipes.length === 0) {
                    this.icicleCache.set(itemId, node);
                    return node;
                }
                
                const recipe = simpleRecipes[0];
                
                const childA = this.getIcicleDecomposition(recipe.sourceA);
                if (childA) node.children.push(childA);
                
                if (recipe.sourceA === recipe.sourceB) {
                     if (childA) node.children.push(childA);
                } else {
                    const childB = this.getIcicleDecomposition(recipe.sourceB);
                    if (childB) node.children.push(childB);
                }
                
                if (node.children.length > 0) {
                     node.width = node.children.reduce((sum, child) => sum + child.width, 0);
                } else {
                     node.width = 1;
                }
                
                this.icicleCache.set(itemId, node);
                return node;
            }

            renderRectangularTree() {
                if (!this.hasData) return;
                
                if (this.renderScheduled) return;
                this.renderScheduled = true;
                
                requestAnimationFrame(() => {
                    const container = document.getElementById('rectangular_tree_container');
                    const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                    const searchName = document.getElementById('icicle_search_input').value.trim().toLowerCase();
                    const searchOnlyRoots = document.getElementById('search_only_roots').checked;
                    
                    const minDepth = parseInt(document.getElementById('min_depth_filter_icicle').value) || 0;
                    const maxDepth = parseInt(document.getElementById('max_depth_filter_icicle').value) || this.icicleMaxDepth + 1;
                    const minWidth = parseInt(document.getElementById('min_width_filter_icicle').value) || 0;
                    const maxWidth = parseInt(document.getElementById('max_width_filter_icicle').value) || 10000; 
                    
                    container.innerHTML = ''; 
                    
                    let icicleRoots = Array.from(this.items.values())
                        .filter(item => item.isDetermined && item.depth > 0);
                    
                    icicleRoots = icicleRoots.filter(item => 
                        item.depth >= minDepth && item.depth <= maxDepth && 
                        item.width >= minWidth && item.width <= maxWidth
                    );
                    
                    if (icicleRoots.length === 0) {
                        container.innerHTML = `<p style="padding: 20px; text-align: center; color: var(--light-text);">Ê†πÊçÆÂΩìÂâçÁ≠õÈÄâÊù°‰ª∂ÔºåÊ≤°ÊúâÂèëÁé∞ÂèØÂàÜËß£ÁöÑÂÖÉÁ¥† (D>0)„ÄÇ</p>`;
                        this.logMessage("ÂÜ∞Êü±ÂõæÊ∏≤ÊüìÂÆåÊàêÔºöÊ≤°ÊúâÊª°Ë∂≥Á≠õÈÄâÊù°‰ª∂ÁöÑÂÖÉÁ¥†„ÄÇ", false);
                        this.renderScheduled = false;
                        return;
                    }

                    const trees = icicleRoots.map(rootItem => this.getIcicleDecomposition(rootItem.id)).filter(t => t);
                    
                    const filteredTrees = trees.filter(tree => {
                        if (!searchName) return true;
                        
                        if (searchOnlyRoots) {
                            return tree.name.toLowerCase().includes(searchName);
                        } else {
                            let found = false;
                            const checkNode = (node) => {
                                if (node.name.toLowerCase().includes(searchName)) { found = true; return; }
                                node.children.forEach(checkNode);
                            };
                            checkNode(tree);
                            return found;
                        }
                    });
                    
                    if (filteredTrees.length === 0) {
                         container.innerHTML = `<p style="padding: 20px; text-align: center; color: var(--light-text);">Êú™ÊâæÂà∞ÂåÖÂê´ "${searchName}" ÁöÑ Simple Ë∑ØÂæÑ„ÄÇ</p>`;
                         this.logMessage(`ÂÜ∞Êü±ÂõæÊêúÁ¥¢ÂÆåÊàêÔºöÊú™ÊâæÂà∞ÂåÖÂê´ "${searchName}" ÁöÑË∑ØÂæÑ„ÄÇ`, false);
                         this.renderScheduled = false;
                        return;
                    }

                    const hasSearchOrFilter = searchName || 
                        minDepth !== 0 || maxDepth !== (this.icicleMaxDepth + 1) ||
                        minWidth !== 0 || maxWidth !== 10000;
                    
                    this.virtualScrollEnabled = !hasSearchOrFilter && filteredTrees.length > 50;
                    
                    if (this.virtualScrollEnabled) {
                        this.allRoots = filteredTrees;
                        this.renderVirtualScroll();
                    } else {
                        this.renderAllRoots(filteredTrees, searchName);
                    }
                    
                    this._constrainIcicleTransform();
                    this._applyIcicleTransform();
                    
                    this.renderScheduled = false;
                });
            }

            renderAllRoots(filteredTrees, searchName) {
                const container = document.getElementById('rectangular_tree_container');
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                container.style.position = 'static';
                container.style.display = 'flex';
                container.style.flexDirection = 'row';
                
                const totalIcicleWidthUnits = filteredTrees.reduce((sum, tree) => sum + tree.width, 0);
                const totalChartWidth = totalIcicleWidthUnits * (this.ICICLE_BASE_UNIT_WIDTH) + filteredTrees.length * 2 * this.ICICLE_NODE_MARGIN; 
                
                container.style.width = `${totalChartWidth}px`; 
                
                let targetNodeX = -1; 
                let accumulatedWidth = 0; 
                
                const fragment = document.createDocumentFragment();
                
                filteredTrees.forEach(tree => {
                    const rootPixelWidth = tree.width * this.ICICLE_BASE_UNIT_WIDTH + 2 * this.ICICLE_NODE_MARGIN;
                    
                    const rootDiv = document.createElement('div');
                    rootDiv.className = 'icicle-root';
                    rootDiv.style.position = 'relative';
                    rootDiv.style.width = `${rootPixelWidth}px`; 

                    const rootHtml = this._renderIcicleNode(tree, tree.width, searchName, accumulatedWidth, (foundX) => {
                        if (targetNodeX === -1) targetNodeX = foundX;
                    });
                    rootDiv.innerHTML = rootHtml.html;
                    fragment.appendChild(rootDiv);
                    
                    accumulatedWidth += rootPixelWidth;
                });
                
                container.appendChild(fragment);
                
                if (targetNodeX !== -1) {
                    const wrapperRect = wrapper.getBoundingClientRect();
                    const wrapperCenterX = wrapperRect.width / 2;
                    
                    this.iciclePanX = (wrapperCenterX / this.icicleZoomLevel) - targetNodeX;
                    this.iciclePanY = 0; 
                } else {
                    this.logMessage(`ÂÜ∞Êü±ÂõæÊ∏≤ÊüìÂÆåÊàêÔºåÊòæÁ§∫ ${filteredTrees.length} ‰∏™Ê†πÂÖÉÁ¥†„ÄÇ`, false);
                }
            }

            renderVirtualScroll() {
                const container = document.getElementById('rectangular_tree_container');
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                container.style.position = 'relative';
                container.style.display = 'block';
                
                const totalWidth = this.allRoots.reduce((sum, tree) => sum + tree.width, 0) * this.ICICLE_BASE_UNIT_WIDTH;
                container.style.width = `${totalWidth}px`;
                
                this.updateVirtualScroll();
                
                this.logMessage(`ÂÜ∞Êü±Âõæ‰ΩøÁî®ËôöÊãüÊªöÂä®ÔºåÊòæÁ§∫ ${this.allRoots.length} ‰∏™Ê†πÂÖÉÁ¥†„ÄÇ`, false);
            }

            updateVirtualScroll() {
                const container = document.getElementById('rectangular_tree_container');
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                if (!this.virtualScrollEnabled || !this.allRoots.length) return;
                
                const viewportWidth = wrapper.clientWidth;
                const viewportHeight = wrapper.clientHeight;
                
                const visibleStartX = -this.iciclePanX / this.icicleZoomLevel;
                const visibleEndX = (-this.iciclePanX + viewportWidth) / this.icicleZoomLevel;
                
                const buffer = viewportWidth / this.icicleZoomLevel * 0.5;
                const visibleStartWithBuffer = Math.max(0, visibleStartX - buffer);
                const visibleEndWithBuffer = visibleEndX + buffer;
                
                let accumulatedWidth = 0;
                const visibleRoots = [];
                
                for (let i = 0; i < this.allRoots.length; i++) {
                    const tree = this.allRoots[i];
                    const rootWidth = tree.width * this.ICICLE_BASE_UNIT_WIDTH;
                    
                    if (accumulatedWidth + rootWidth >= visibleStartWithBuffer && accumulatedWidth <= visibleEndWithBuffer) {
                        visibleRoots.push({
                            tree,
                            startX: accumulatedWidth,
                            index: i
                        });
                    }
                    
                    accumulatedWidth += rootWidth;
                    if (accumulatedWidth > visibleEndWithBuffer) break;
                }
                
                this.renderVisibleRoots(visibleRoots);
            }

            renderVisibleRoots(visibleRoots) {
                const container = document.getElementById('rectangular_tree_container');
                
                const fragment = document.createDocumentFragment();
                
                const existingRoots = container.querySelectorAll('.icicle-root');
                existingRoots.forEach(root => {
                    root.style.display = 'none';
                });
                
                visibleRoots.forEach(({tree, startX, index}) => {
                    const rootPixelWidth = tree.width * this.ICICLE_BASE_UNIT_WIDTH;
                    
                    let rootDiv = container.querySelector(`.icicle-root[data-index="${index}"]`);
                    
                    if (!rootDiv) {
                        rootDiv = document.createElement('div');
                        rootDiv.className = 'icicle-root';
                        rootDiv.setAttribute('data-index', index);
                        rootDiv.style.width = `${rootPixelWidth}px`;
                        rootDiv.style.left = `${startX}px`;
                        
                        const rootHtml = this._renderIcicleNode(tree, tree.width, '', startX);
                        rootDiv.innerHTML = rootHtml.html;
                        
                        fragment.appendChild(rootDiv);
                    } else {
                        rootDiv.style.left = `${startX}px`;
                        rootDiv.style.display = 'block';
                    }
                });
                
                container.appendChild(fragment);
            }

            _renderIcicleNode(node, parentWidthUnits, searchName, currentX, setTargetXCallback) {
                const isHighlight = searchName.length > 0 && node.name.toLowerCase().includes(searchName);
                const color = this._getDepthColor(node.depth, isHighlight);
                
                const nodeWidthPercent = (node.width / parentWidthUnits) * 100;
                
                const nodePixelWidth = node.width * this.ICICLE_BASE_UNIT_WIDTH + 2 * this.ICICLE_NODE_MARGIN;
                
                let html = `<div class="icicle-node-container" style="width: ${nodeWidthPercent}%; min-width: 10px;">`;
                
                html += `<div class="icicle-node-label" 
                            style="background-color: ${color};" 
                            title="ID:${node.id} | D:${node.depth} | W:${node.width}"
                            data-node-id="${node.id}">
                            ${node.name}
                        </div>`;
                
                if (isHighlight && setTargetXCallback && setTargetXCallback.isCalled !== true) {
                    const nodeCenterX = currentX + nodePixelWidth / 2;
                    setTargetXCallback(nodeCenterX);
                    setTargetXCallback.isCalled = true; 
                }

                if (node.children.length > 0) {
                    html += `<div class="icicle-children-container">`;
                    
                    let childAccumulatedX = currentX + this.ICICLE_NODE_MARGIN; 
                    node.children.forEach(child => {
                        const childResult = this._renderIcicleNode(child, node.width, searchName, childAccumulatedX, setTargetXCallback);
                        html += childResult.html;
                        childAccumulatedX += child.width * this.ICICLE_BASE_UNIT_WIDTH + 2 * this.ICICLE_NODE_MARGIN;
                    });

                    html += `</div>`; 
                } else {
                     html += `<div style="flex-grow: 1;"></div>`;
                }

                html += `</div>`; 
                return { html: html, width: nodePixelWidth };
            }

            initialRenderDAG() {
                if (!this.hasData) return;
                const searchName = document.getElementById('dag_search_input').value.trim();
                const container = document.getElementById('dag_graph_container');
                const searchItem = this.getItemByName(searchName);
                
                if (this.network) this.network.destroy();
                this.network = null;
                this.expandedNodeIds.clear();

                if (!searchName || !searchItem || !searchItem.isDetermined) {
                     container.innerHTML = `<p style="padding: 20px; text-align: center; color: var(--light-text);">ËØ∑ËæìÂÖ•‰∏Ä‰∏™ÊúâÊïàÁöÑÁ°ÆÂÆöÂÖÉÁ¥†ÂêçÁß∞ËøõË°åÊêúÁ¥¢„ÄÇ</p>`;
                     return;
                }

                this.expandedNodeIds.add(searchItem.id);
                
                this.dagNodes = new vis.DataSet();
                this.dagEdges = new vis.DataSet(); 

                this.renderNetwork(); 
                this._updateGraphFromExpandedSet(); 
                
                this.logMessage(`DAGÔºöÂºÄÂßãÊêúÁ¥¢ÂÖÉÁ¥† "${searchName}"„ÄÇ`, false);
                
                this.network.once("stabilizationIterationsDone", () => {
                    this.network.setOptions({ physics: false });
                    this.network.focus(searchItem.id, {scale: 1.0, animation: {duration: 500, easingFunction: "easeInOutQuad"}});
                    this.logMessage(`DAGÔºöÂõæË°®Á®≥ÂÆöÔºåËÅöÁÑ¶Âà∞ "${searchName}"„ÄÇ`, false);
                });
            }
            
            toggleNodeExpansion(nodeId) {
                 if (!this.dagNodes.get(nodeId)) return; 

                this.dagNodes.update({ id: nodeId, isExpanding: true, color: { border: '#e53935' } });
                
                if (this.expandedNodeIds.has(nodeId)) {
                    this.expandedNodeIds.delete(nodeId);
                    this.logMessage(`DAGÔºöÊî∂Ëµ∑ËäÇÁÇπ "${this.getItemById(nodeId).name}"„ÄÇ`, false);
                } else {
                    this.expandedNodeIds.add(nodeId);
                    this.logMessage(`DAGÔºöÂ±ïÂºÄËäÇÁÇπ "${this.getItemById(nodeId).name}"„ÄÇ`, false);
                }
                
                this._updateGraphFromExpandedSet();

                const isExpanded = this.expandedNodeIds.has(nodeId);
                const isBase = this.getItemById(nodeId)?.depth === 0;
                const newBorderColor = isExpanded ? '#1e88e5' : (isBase ? '#f57c00' : '#3f51b5');
                
                this.dagNodes.update({ 
                    id: nodeId, 
                    isExpanding: false, 
                    label: this.getItemById(nodeId).name, 
                    color: { border: newBorderColor } 
                });
            }

            _updateGraphFromExpandedSet() {
                if (!this.dagNodes || !this.dagEdges || !this.network) return;

                const showNonSimple = document.getElementById('non_simple_toggle')?.checked ?? false;
                const onlyParents = document.getElementById('expand_only_parents')?.checked ?? true;
                const childrenAndPeers = document.getElementById('expand_children_and_peers')?.checked ?? false;
                
                const minDepth = parseInt(document.getElementById('min_depth_filter').value) || 0;
                const maxDepth = parseInt(document.getElementById('max_depth_filter').value) || this.icicleMaxDepth + 1;
                const minWidth = parseInt(document.getElementById('min_width_filter').value) || 0;
                const maxWidth = parseInt(document.getElementById('max_width_filter').value) || 10000; 

                const nodesToKeep = new Set();
                const edgesToKeep = [];
                
                this.expandedNodeIds.forEach(centerId => {
                    const centerItem = this.getItemById(centerId);
                    if (!centerItem || !centerItem.isDetermined) return;
                    
                    nodesToKeep.add(centerId); 
                    
                    if (onlyParents) {
                        const recipesForProduct = this.recipesByProduct.get(centerId) || [];
                        recipesForProduct.forEach(recipe => {
                            if (recipe.simple || showNonSimple) {
                                nodesToKeep.add(recipe.sourceA);
                                edgesToKeep.push(this._createEdgeDefinition(recipe.sourceA, centerId, recipe));
                                
                                if (recipe.sourceA !== recipe.sourceB) {
                                    nodesToKeep.add(recipe.sourceB);
                                    edgesToKeep.push(this._createEdgeDefinition(recipe.sourceB, centerId, recipe));
                                }
                            }
                        });
                    }

                    if (childrenAndPeers) {
                        const recipesForSource = this.recipesBySource.get(centerId) || [];
                        recipesForSource.forEach(recipe => {
                            if (recipe.simple || showNonSimple) {
                                const otherSourceId = recipe.sourceA === centerId ? recipe.sourceB : recipe.sourceA;
                                
                                nodesToKeep.add(recipe.product);
                                edgesToKeep.push(this._createEdgeDefinition(centerId, recipe.product, recipe));
                                
                                nodesToKeep.add(otherSourceId);
                                edgesToKeep.push(this._createEdgeDefinition(otherSourceId, recipe.product, recipe)); 
                            }
                        });
                    }
                });
                
                const filteredNodesToKeep = new Set();
                nodesToKeep.forEach(id => {
                     const item = this.getItemById(id);
                     if (item?.isDetermined && 
                         item.depth >= minDepth && item.depth <= maxDepth && 
                         item.width >= minWidth && item.width <= maxWidth) {
                        filteredNodesToKeep.add(id);
                     }
                });
                
                const initialSearchId = this.getItemByName(document.getElementById('dag_search_input').value.trim())?.id;
                if (initialSearchId && this.expandedNodeIds.has(initialSearchId) && !filteredNodesToKeep.has(initialSearchId)) {
                    this.expandedNodeIds.clear(); 
                    this.dagNodes.clear();
                    this.dagEdges.clear();
                    this.network.setData({ nodes: this.dagNodes, edges: this.dagEdges });
                    this.logMessage("DAGÔºöÂàùÂßãÊêúÁ¥¢ËäÇÁÇπË¢´ D/W Á≠õÈÄâÂô®ÊéíÈô§ÔºåÂ∑≤ÈáçÁΩÆÂõæË°®„ÄÇ", true);
                    return; 
                }
                
                const currentNodes = this.dagNodes.getIds();
                const nodesToRemove = currentNodes.filter(id => !filteredNodesToKeep.has(id));
                const nodesToAdd = Array.from(filteredNodesToKeep).filter(id => !this.dagNodes.get(id));
                
                const nodesToUpdate = currentNodes.filter(id => filteredNodesToKeep.has(id)).map(id => {
                    const item = this.getItemById(id);
                    const isExpanded = this.expandedNodeIds.has(id);
                    const isBase = item?.depth === 0;
                    
                    const borderColor = isExpanded ? '#1e88e5' : (isBase ? '#f57c00' : '#3f51b5');
                    
                    return {
                        id: id,
                        label: item.name, 
                        color: {
                            border: borderColor
                        }
                    };
                });

                this.dagNodes.remove(nodesToRemove);
                this.dagNodes.update(nodesToUpdate);
                this._addNodesToGraph(nodesToAdd); 

                const uniqueEdges = [];
                const addedEdges = new Set();
                this.dagEdges.clear();
                
                edgesToKeep.forEach(edge => {
                    if (filteredNodesToKeep.has(edge.from) && filteredNodesToKeep.has(edge.to)) {
                        if (!addedEdges.has(edge.id)) {
                            uniqueEdges.push(edge);
                            addedEdges.add(edge.id);
                        }
                    }
                });
                
                this.dagEdges.add(uniqueEdges);

                this.network.setOptions({ physics: true });
                this.network.once("stabilizationIterationsDone", () => {
                    this.network.setOptions({ physics: false });
                    this.network.fit();
                    this.logMessage("DAGÔºöÂõæË°®Á≠õÈÄâ/Êõ¥Êñ∞ÂÆåÊàê„ÄÇ", false);
                });
            }

            _createEdgeDefinition(fromId, toId, recipe) {
                const recipeKey = JSON.stringify(recipe.id);
                const isSimple = recipe.simple;
                const edgeId = `${fromId}_to_${toId}_${recipeKey}`;
                
                const edgeColor = isSimple ? '#4caf50' : '#9e9e9e'; 
                const edgeDashes = !isSimple;
                const baseTitle = `${this.getItemById(recipe.sourceA)?.name} + ${this.getItemById(recipe.sourceB)?.name} = ${this.getItemById(recipe.product)?.name}\nSimple: ${isSimple ? 'Yes' : 'No'}`;

                return {
                    id: edgeId,
                    from: fromId,
                    to: toId,
                    arrows: 'to',
                    color: { color: edgeColor }, 
                    dashes: edgeDashes,
                    width: 2,
                    title: baseTitle,
                    isSimple: isSimple
                };
            }

            _addNodesToGraph(itemIds) {
                const nodesToAdd = [];
                itemIds.forEach(itemId => {
                    const item = this.getItemById(itemId);
                    if (!item || !item.isDetermined) return;
                    
                    const isExpanded = this.expandedNodeIds.has(itemId);
                    const isBase = item.depth === 0;

                    const borderColor = isExpanded ? '#1e88e5' : (isBase ? '#f57c00' : '#3f51b5');

                    nodesToAdd.push({
                        id: itemId,
                        label: item.name,
                        title: `ID: ${item.id}\nDepth: ${item.depth}\nWidth: ${item.width}\nExpanded: ${isExpanded ? 'Yes' : 'No'}`,
                        shape: 'box',
                        size: 30, 
                        borderWidth: 3, 
                        font: { color: 'black', size: 14 },
                        isExpanded: isExpanded, 
                        color: {
                            background: isBase ? '#ff9800' : '#bbdefb', 
                            border: borderColor, 
                            highlight: { background: '#ffcdd2', border: '#e53935' }
                        }
                    });
                });
                this.dagNodes.add(nodesToAdd);
            }

            renderNetwork() {
                const container = document.getElementById('dag_graph_container');
                container.innerHTML = ''; 

                const data = { nodes: this.dagNodes, edges: this.dagEdges };
                const options = {
                    layout: { hierarchical: false },
                    edges: {
                        smooth: { type: 'dynamic' },
                        arrows: 'to',
                        width: 1.5,
                    },
                    physics: {
                        enabled: true,
                        barnesHut: {
                            gravitationalConstant: -2000, 
                            centralGravity: 0.1, 
                            springLength: 200, 
                            springConstant: 0.05
                        },
                        stabilization: {
                            iterations: 1000,
                            updateInterval: 50, 
                            onlyNecessary: true
                        }
                    },
                    interaction: { 
                        dragNodes: true, 
                        zoomView: true, 
                        dragView: true,
                        multiselect: false
                    }
                };

                this.network = new vis.Network(container, data, options);

                this.network.on("click", (params) => {
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        this.toggleNodeExpansion(nodeId);
                    }
                });
            }
            
            toggleFullscreen(elementId) {
                const element = document.getElementById(elementId);
                
                if (!document.fullscreenElement) {
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                    
                    element.classList.add('fullscreen');
                    
                    if (elementId === 'dag_graph_container' && this.network) {
                        setTimeout(() => {
                            this.network.fit();
                        }, 100);
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                    
                    element.classList.remove('fullscreen');
                    
                    if (elementId === 'dag_graph_container' && this.network) {
                        setTimeout(() => {
                            this.network.fit();
                        }, 100);
                    }
                }
            }
        }

        const app = new VisualizationApp();
        
        document.addEventListener('DOMContentLoaded', () => {
            app.setupIcicleZoom();
            app.loadInitialData();
            
            document.getElementById('json_file_input').addEventListener('change', () => {
                if (document.getElementById('json_file_input').files.length > 0) {
                    app.logMessage('Êñá‰ª∂Â∑≤ÈÄâÊã©ÔºåËØ∑ÁÇπÂáª "ÂØºÂÖ• JSON Êï∞ÊçÆ"„ÄÇ', false);
                } else if (!app.hasData) {
                    app.logMessage('ËØ∑ÂØºÂÖ• JSON Êï∞ÊçÆ„ÄÇ', false);
                }
            });
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);
            
            function handleFullscreenChange() {
                const fullscreenElement = document.fullscreenElement || 
                                         document.webkitFullscreenElement || 
                                         document.msFullscreenElement;
                
                if (!fullscreenElement) {
                    document.querySelectorAll('.fullscreen').forEach(el => {
                        el.classList.remove('fullscreen');
                    });
                }
            }
        });
    </script>
</body>
</html>
