<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成数据可视化</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        :root {
            --primary-color: #3f51b5;
            --secondary-color: #4caf50;
            --accent-color: #ff9800;
            --text-color: #333;
            --bg-color: #eef1f6;
            --card-bg: white;
            --border-radius: 12px;
        }

        * {
            box-sizing: border-box;
        }

        body { 
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            padding: 10px; 
            background-color: var(--bg-color); 
            margin: 0;
            color: var(--text-color);
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        
        .container { 
            max-width: 1400px; 
            margin: auto; 
            background: var(--card-bg); 
            padding: 20px; 
            border-radius: var(--border-radius); 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); 
        }

        h1 { 
            color: var(--primary-color); 
            border-bottom: 3px solid var(--primary-color); 
            padding-bottom: 8px; 
            margin-bottom: 15px; 
            font-weight: 400; 
            font-size: 1.6rem;
        }
        h2 { 
            color: var(--text-color); 
            margin-top: 20px; 
            border-left: 5px solid var(--accent-color); 
            padding-left: 12px; 
            font-weight: 500; 
            font-size: 1.3rem;
        }
        
        .chart-container { 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            margin-top: 15px;
            background: #fafafa;
            overflow: hidden; 
            position: relative;
        }
        
        .controls { 
            margin-bottom: 15px; 
            display: flex; 
            align-items: center; 
            flex-wrap: wrap; 
            gap: 8px; 
            padding: 8px 0; 
        }
        .controls input[type="file"], 
        .controls button, 
        .controls input[type="text"], 
        .controls input[type="number"] { 
            padding: 10px 12px; 
            border-radius: 6px; 
            border: 1px solid #ccc; 
            font-size: 14px; 
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            min-height: 44px; /* 提高触摸区域 */
        }
        .controls button { 
            background-color: var(--secondary-color); 
            color: white; 
            cursor: pointer; 
            border: none;
            width: auto !important; 
            font-weight: 500;
        }
        .controls button:hover, 
        .controls button:active { 
            background-color: #388e3c; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); 
        }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .tabs {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .tabs::-webkit-scrollbar {
            display: none;
        }
        .tabs button {
            padding: 12px 16px;
            border: none;
            cursor: pointer;
            background-color: #e0e0e0;
            border-bottom: 3px solid transparent;
            border-radius: 8px 8px 0 0;
            font-weight: 500;
            flex-shrink: 0;
            margin-right: 5px;
            transition: all 0.2s;
        }
        .tabs button.active {
            background-color: white;
            border-bottom: 3px solid var(--primary-color);
            font-weight: bold;
            color: var(--primary-color);
        }
        
        #status_message { 
            color: #e53935; 
            font-weight: bold; 
            margin-left: 10px; 
            word-break: break-word;
            flex: 1;
            min-width: 100%;
        }

        #log_area {
            min-height: 20px; 
            padding: 10px; 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            margin-bottom: 15px; 
            background: #fdfdff; 
            font-size: 13px; 
            color: #555; 
            overflow-y: auto; 
            max-height: 100px;
        }
        #log_area p {
             margin: 0;
             padding: 2px 0;
             border-bottom: 1px dashed #eee;
        }
        #log_area p:last-child {
             border-bottom: none;
        }

        #rectangular_tree_container_wrapper {
            height: 500px;
            overflow: hidden; 
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            position: relative;
        }

        #rectangular_tree_container_wrapper.is-dragging {
            cursor: grabbing;
        }

        #rectangular_tree_container {
            height: 100%;
            display: flex; 
            align-items: flex-start; 
            flex-wrap: nowrap;
            transform-origin: 0 0; 
            transition: transform 0.1s ease-out; 
            min-width: 100%; 
            position: relative;
        }
        
        .icicle-root {
            height: 100%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            position: absolute;
            top: 0;
        }

        .icicle-node-container {
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 2px;
            margin-top: -1px; 
        }

        .icicle-node-label {
            height: 35px;
            line-height: 35px;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: #fff;
            box-sizing: border-box;
            overflow: hidden;
            white-space: nowrap;
            cursor: pointer;
            width: 100%; 
            margin: 0; 
            padding: 0 5px;
            border-radius: 2px; 
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), inset 0 0 5px rgba(255, 255, 255, 0.4);
            transition: background-color 0.3s, box-shadow 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.5); 
        }

        .icicle-children-container {
            display: flex;
            flex-direction: row;
            width: 100%; 
            flex-grow: 1; 
        }
        
        #dag_graph_container {
            height: 500px; 
            position: relative;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #555;
            cursor: pointer;
            user-select: none;
            white-space: nowrap; 
            margin: 5px 0;
        }

        .toggle-switch input {
            display: none;
        }

        .slider {
            width: 45px;
            height: 24px;
            background-color: #ccc;
            border-radius: 12px;
            position: relative;
            margin-left: 10px;
            margin-right: 8px;
            transition: background-color 0.4s;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .slider:before {
            content: "";
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: white;
            top: 3px;
            left: 3px;
            transition: transform 0.4s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(21px);
        }

        /* 全屏按钮 */
        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .fullscreen-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            body {
                padding: 8px;
            }
            
            .container {
                padding: 15px;
                border-radius: 10px;
            }
            
            h1 {
                font-size: 1.4rem;
                padding-bottom: 6px;
            }
            
            h2 {
                font-size: 1.2rem;
                margin-top: 15px;
                padding-left: 10px;
            }
            
            .controls {
                gap: 8px;
                padding: 8px 0;
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls > * {
                width: 100% !important;
                margin-bottom: 5px;
            }
            
            .controls input[type="file"],
            .controls button,
            .controls input[type="text"],
            .controls input[type="number"] {
                padding: 12px;
                font-size: 16px; /* 防止iOS自动缩放 */
                width: 100% !important;
            }
            
            .controls button {
                padding: 12px 16px;
            }
            
            .tabs {
                margin-bottom: 10px;
            }
            
            .tabs button {
                padding: 10px 14px;
                font-size: 14px;
            }
            
            #status_message {
                margin-left: 0;
                margin-top: 10px;
                text-align: center;
                order: 10; /* 放在最后 */
            }
            
            #rectangular_tree_container_wrapper,
            #dag_graph_container {
                height: 400px;
            }
            
            .icicle-node-label {
                font-size: 11px;
                height: 30px;
                line-height: 30px;
            }
            
            .toggle-switch {
                font-size: 14px;
                margin-top: 5px;
                margin-bottom: 5px;
            }
            
            #log_area {
                max-height: 80px;
                font-size: 12px;
            }
            
            /* 调整输入框组布局 */
            .filter-group {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                align-items: center;
                width: 100%;
            }
            
            .filter-group span {
                display: inline-block;
                width: 60px;
                text-align: left;
                margin-right: 5px;
            }
            
            .filter-group input[type="number"] {
                width: calc(50% - 35px) !important;
                display: inline-block;
            }
            
            .controls input[type="text"] {
                width: 100% !important;
            }
            
            /* 优化搜索框布局 */
            .search-container {
                width: 100%;
            }
            
            .search-container input {
                width: 100% !important;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.3rem;
            }
            
            h2 {
                font-size: 1.1rem;
            }
            
            #rectangular_tree_container_wrapper,
            #dag_graph_container {
                height: 350px;
            }
            
            .icicle-node-label {
                font-size: 9px;
                height: 25px;
                line-height: 25px;
            }
            
            .toggle-switch {
                font-size: 13px;
            }
            
            .controls {
                gap: 5px;
            }
        }

        /* 防止移动端输入框缩放 */
        @media (max-width: 768px) {
            input[type="text"],
            input[type="number"] {
                font-size: 16px !important;
            }
        }

        /* 全屏样式 */
        .fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 9999;
            background: white;
            padding: 10px;
        }

        .fullscreen .chart-container {
            height: calc(100% - 60px) !important;
        }

        /* 优化性能的样式 */
        .icicle-node-label {
            will-change: transform;
        }

        /* 加载指示器 */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .vis-network {
            /* 优化网络图性能 */
            transform: translateZ(0);
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>合成数据可视化</h1>

        <div class="controls">
            <input type="file" id="json_file_input" accept="application/json">
            <button onclick="app.importData()">导入 JSON 数据</button>
            <button onclick="app.clearStorageData()">清除存储数据</button>
            <span id="status_message">准备就绪。</span>
        </div>
        
        <div id="log_area">
            <p style="margin: 0; padding: 0;">日志/状态信息:</p>
        </div>

        <div class="tabs">
            <button id="tab1-btn" class="active" onclick="app.showTab(1)">矩形冰柱图</button>
            <button id="tab2-btn" onclick="app.showTab(2)">有向无环图</button>
        </div>

        <div id="tab1" class="tab-content active">
            <h2>矩形冰柱图</h2>
            <div class="controls">
                <div class="search-container">
                    <input type="text" id="icicle_search_input" placeholder="输入元素名称实时搜索" oninput="app.debouncedRenderRectangularTree()" list="item_names_datalist">
                </div>
                
                <label class="toggle-switch">
                    <input type="checkbox" id="search_only_roots" onchange="app.debouncedRenderRectangularTree()">
                    <span class="slider"></span>
                    只搜索根节点
                </label>
                
                <div class="filter-group">
                    <span>深度 (D):</span>
                    <input type="number" id="min_depth_filter_icicle" placeholder="Min D" oninput="app.debouncedRenderRectangularTree()">
                    <input type="number" id="max_depth_filter_icicle" placeholder="Max D" oninput="app.debouncedRenderRectangularTree()">
                </div>
                
                <div class="filter-group">
                    <span>宽度 (W):</span>
                    <input type="number" id="min_width_filter_icicle" placeholder="Min W" oninput="app.debouncedRenderRectangularTree()">
                    <input type="number" id="max_width_filter_icicle" placeholder="Max W" oninput="app.debouncedRenderRectangularTree()">
                </div>
            </div>
            <div id="rectangular_tree_container_wrapper" class="chart-container">
                 <button class="fullscreen-btn" onclick="app.toggleFullscreen('rectangular_tree_container_wrapper')">
                    <span>全屏</span>
                 </button>
                 <div id="rectangular_tree_container" style="transform: translate(0px, 0px) scale(1);">
                    <p style="padding: 20px;">请导入数据并等待图表渲染。</p>
                 </div>
            </div>
        </div>

        <div id="tab2" class="tab-content">
            <h2>有向无环图</h2>
            <p>点击节点展开/收起其邻居。</p>
            <div class="controls">
                <div class="search-container">
                    <input type="text" id="dag_search_input" placeholder="输入要搜索的元素名称" list="item_names_datalist" oninput="app.debouncedInitialRenderDAG()">
                </div>
                
                <label class="toggle-switch">
                    <input type="checkbox" id="non_simple_toggle" onchange="app.debouncedUpdateGraph()">
                    <span class="slider"></span>
                    显示非最简路径
                </label>
                
                <label class="toggle-switch">
                    <input type="checkbox" id="expand_only_parents" checked onchange="app.debouncedUpdateGraph()">
                    <span class="slider"></span>
                    展开素材
                </label>

                <label class="toggle-switch">
                    <input type="checkbox" id="expand_children_and_peers" onchange="app.debouncedUpdateGraph()">
                    <span class="slider"></span>
                    展开产物
                </label>
            </div>
            <div class="controls">
                <div class="filter-group">
                    <span>深度 (D):</span>
                    <input type="number" id="min_depth_filter" placeholder="Min D" oninput="app.debouncedUpdateGraph()">
                    <input type="number" id="max_depth_filter" placeholder="Max D" oninput="app.debouncedUpdateGraph()">
                </div>
                
                <div class="filter-group">
                    <span>宽度 (W):</span>
                    <input type="number" id="min_width_filter" placeholder="Min W" oninput="app.debouncedUpdateGraph()">
                    <input type="number" id="max_width_filter" placeholder="Max W" oninput="app.debouncedUpdateGraph()">
                </div>
            </div>

            <div id="dag_graph_container" class="chart-container">
                <button class="fullscreen-btn" onclick="app.toggleFullscreen('dag_graph_container')">
                    <span>全屏</span>
                </button>
                 <p style="padding: 20px;">请在上方输入框中输入元素名称进行搜索。</p>
            </div>
            <datalist id="item_names_datalist"></datalist>
        </div>
        
    </div>

    <script>
        
        class Item {
            constructor(id, name, depth = -1, width = 1) {
                this.id = id; this.name = name; this.depth = depth; this.width = width;
            }
            get isDetermined() { return this.id >= 0; }
        }

        class Recipe {
            constructor(idA, idB, idC, simple = false) {
                const [lid, rid] = idA <= idB ? [idA, idB] : [idB, idA];
                this.id = [lid, rid, idC]; 
                this.simple = simple; 
            }
            get sourceA() { return this.id[0]; }
            get sourceB() { return this.id[1]; }
            get product() { return this.id[2]; }
        }

        class VisualizationApp {
            constructor() {
                this.items = new Map();     
                this.recipes = new Map();   
                this.initialElements = ['金', '木', '水', '火', '土'];
                this.hasData = false;
                this.recipesByProduct = new Map();  
                this.recipesBySource = new Map();   
                this.itemNames = new Map();         
                
                this.currentTab = 1;
                this.network = null;    
                this.dagNodes = null;   
                this.dagEdges = null;   

                this.expandedNodeIds = new Set(); 
                
                this.ICICLE_BASE_UNIT_WIDTH = 35; 
                this.ICICLE_NODE_MARGIN = 2;      
                
                this.icicleZoomLevel = 1.0;
                this.icicleMaxDepth = 1; 
                this.iciclePanX = 0;
                this.iciclePanY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // 防抖函数
                this.debounceTimers = {};
                
                // 性能优化
                this.renderScheduled = false;
                this.virtualScrollEnabled = true;
                this.visibleRoots = [];
                this.allRoots = [];
                this.virtualScrollOffset = 0;
                this.visibleRange = { start: 0, end: 0 };
                this.virtualScrollRafId = null;
                
                // 搜索状态
                this.searchOnlyRoots = false;
                
                // 缓存
                this.icicleCache = new Map();
            }

            // 防抖函数
            debounce(func, wait, immediate) {
                return function() {
                    const context = this;
                    const args = arguments;
                    const later = function() {
                        this.debounceTimers[func] = null;
                        if (!immediate) func.apply(context, args);
                    }.bind(this);
                    const callNow = immediate && !this.debounceTimers[func];
                    clearTimeout(this.debounceTimers[func]);
                    this.debounceTimers[func] = setTimeout(later, wait);
                    if (callNow) func.apply(context, args);
                }.bind(this);
            }

            // 初始化防抖函数
            initDebounceFunctions() {
                this.debouncedRenderRectangularTree = this.debounce(this.renderRectangularTree, 300);
                this.debouncedInitialRenderDAG = this.debounce(this.initialRenderDAG, 300);
                this.debouncedUpdateGraph = this.debounce(this._updateGraphFromExpandedSet, 300);
            }

            logMessage(message, isError = false) {
                const logArea = document.getElementById('log_area');
                const statusEl = document.getElementById('status_message');
                
                statusEl.textContent = message;
                statusEl.style.color = isError ? '#e53935' : '#4caf50';

                const now = new Date();
                const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
                
                const logEntry = document.createElement('p');
                logEntry.style.color = isError ? '#d32f2f' : '#555';
                logEntry.innerHTML = `[${timeString}] ${message}`;

                logArea.prepend(logEntry);

                while (logArea.children.length > 20) {
                    logArea.removeChild(logArea.lastElementChild);
                }
            }

            loadInitialData() {
                const storedData = localStorage.getItem('synthesis_data');
                if (storedData) {
                    try {
                        const importedData = JSON.parse(storedData);
                        this._processData(importedData, '数据已从本地存储加载。');
                        return;
                    } catch (e) {
                        this.logMessage("加载本地数据失败。请导入新的 JSON 文件。", true);
                        console.error("加载本地数据失败:", e);
                    }
                }
                this.logMessage('请导入 JSON 数据。', false);
            }

            saveDataToStorage(data) {
                try {
                    localStorage.setItem('synthesis_data', JSON.stringify(data));
                    this.logMessage("数据已自动保存到本地存储。", false);
                } catch (e) {
                    this.logMessage("保存数据到本地存储失败。", true);
                    console.error("保存数据到本地存储失败:", e);
                }
            }

            clearStorageData() {
                localStorage.removeItem('synthesis_data');
                this.hasData = false;
                this.logMessage('已清除本地存储的数据。请重新导入文件。', true);
                document.getElementById('rectangular_tree_container').innerHTML = '<p style="padding: 20px;">请导入数据并等待图表渲染。</p>';
                document.getElementById('dag_graph_container').innerHTML = '<p style="padding: 20px;">请在上方输入框中输入元素名称进行搜索。</p>';
                this.icicleZoomLevel = 1.0;
                this.iciclePanX = 0;
                this.iciclePanY = 0;
                this._applyIcicleTransform();
                this.icicleCache.clear();
            }

            importData() {
                const input = document.getElementById('json_file_input');
                const file = input.files[0];
                if (!file) {
                    this.logMessage('请选择一个 JSON 文件。', true);
                    return;
                }

                this.logMessage('正在读取文件...');
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    await new Promise(resolve => setTimeout(resolve, 0)); 
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!importedData.items || !importedData.recipes) {
                            throw new Error("文件格式不正确，缺少 items 或 recipes 字段。");
                        }
                        
                        this._processData(importedData, `数据导入成功！总Item数: ${importedData.items.length}。`);
                        this.saveDataToStorage(importedData);

                    } catch (error) {
                        this.logMessage(`数据导入失败: ${error.message}`, true);
                        this.hasData = false;
                    }
                };
                reader.readAsText(file);
            }

            _processData(importedData, successMessage) {
                // 显示加载指示器
                const statusEl = document.getElementById('status_message');
                statusEl.innerHTML = '<div class="loading"></div>处理数据中...';
                
                // 使用setTimeout让UI有机会更新
                setTimeout(() => {
                    this.items = new Map();
                    this.recipes = new Map(importedData.recipes);
                    
                    let maxDepth = 1;
                    importedData.items.forEach(([id, itemData]) => {
                        const item = Object.assign(new Item(), itemData);
                        this.items.set(item.id, item);
                        if (item.isDetermined) {
                            this.itemNames.set(item.name, item);
                            if (item.depth > maxDepth) maxDepth = item.depth;
                        }
                    });
                    this.icicleMaxDepth = maxDepth; 

                    this.preprocessRecipes();
                    this.hasData = true;

                    this.logMessage(successMessage, false);
                    this.initSelectorsAndGraphs();
                    
                    // 移除加载指示器
                    statusEl.innerHTML = successMessage;
                    
                    // 清空缓存
                    this.icicleCache.clear();
                }, 10);
            }

            preprocessRecipes() {
                this.recipesByProduct.clear();
                this.recipesBySource.clear();

                this.recipes.forEach((isSimple, key) => {
                    const [lid, rid, pid] = JSON.parse(key);
                    const recipe = new Recipe(lid, rid, pid, isSimple);

                    if (!this.recipesByProduct.has(pid)) this.recipesByProduct.set(pid, []);
                    this.recipesByProduct.get(pid).push(recipe);

                    if (!this.recipesBySource.has(lid)) this.recipesBySource.set(lid, []);
                    this.recipesBySource.get(lid).push(recipe);
                    
                    if (lid !== rid) {
                        if (!this.recipesBySource.has(rid)) this.recipesBySource.set(rid, []);
                        this.recipesBySource.get(rid).push(recipe);
                    }
                });
            }

            getItemById(id) {
                return this.items.get(id);
            }

            getItemByName(name) {
                return this.itemNames.get(name);
            }

            initSelectorsAndGraphs() {
                this.initDebounceFunctions();
                this.renderDatalist();
                this.renderRectangularTree(); 
                this.showTab(this.currentTab);
            }

            showTab(tabNumber) {
                document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.tabs button').forEach(el => el.classList.remove('active'));

                document.getElementById(`tab${tabNumber}`).classList.add('active');
                document.getElementById(`tab${tabNumber}-btn`).classList.add('active');
                this.currentTab = tabNumber;
                
                if (tabNumber === 1 && this.hasData) {
                    this.renderRectangularTree();
                }
            }
            
            renderDatalist() {
                const datalist = document.getElementById('item_names_datalist');
                const determinedItems = Array.from(this.items.values()).filter(item => item.isDetermined);
                determinedItems.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
                datalist.innerHTML = determinedItems.map(item => `<option value="${item.name}">`).join('');
            }

            setupIcicleZoom() {
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                // 鼠标事件
                wrapper.addEventListener('mousedown', (e) => {
                    if (this.currentTab !== 1 || e.button !== 0) return; 
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    wrapper.classList.add('is-dragging');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging || this.currentTab !== 1) return;
                    
                    const dx = e.clientX - this.lastMouseX;
                    const dy = e.clientY - this.lastMouseY;
                    
                    this.iciclePanX += dx / this.icicleZoomLevel;
                    this.iciclePanY += dy / this.icicleZoomLevel;

                    this.iciclePanY = Math.min(0, this.iciclePanY); 

                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;

                    this._applyIcicleTransform();
                    
                    // 在拖动时更新虚拟滚动
                    if (this.virtualScrollEnabled) {
                        this.scheduleVirtualScrollUpdate();
                    }
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    wrapper.classList.remove('is-dragging');
                });

                // 触摸事件支持
                wrapper.addEventListener('touchstart', (e) => {
                    if (this.currentTab !== 1 || e.touches.length !== 1) return;
                    this.isDragging = true;
                    const touch = e.touches[0];
                    this.lastMouseX = touch.clientX;
                    this.lastMouseY = touch.clientY;
                    wrapper.classList.add('is-dragging');
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (!this.isDragging || this.currentTab !== 1 || e.touches.length !== 1) return;
                    const touch = e.touches[0];
                    
                    const dx = touch.clientX - this.lastMouseX;
                    const dy = touch.clientY - this.lastMouseY;
                    
                    this.iciclePanX += dx / this.icicleZoomLevel;
                    this.iciclePanY += dy / this.icicleZoomLevel;

                    this.iciclePanY = Math.min(0, this.iciclePanY); 

                    this.lastMouseX = touch.clientX;
                    this.lastMouseY = touch.clientY;

                    this._applyIcicleTransform();
                    
                    // 在拖动时更新虚拟滚动
                    if (this.virtualScrollEnabled) {
                        this.scheduleVirtualScrollUpdate();
                    }
                    
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchend', () => {
                    this.isDragging = false;
                    wrapper.classList.remove('is-dragging');
                });

                // 双指缩放
                let initialDistance = null;
                
                wrapper.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        initialDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        e.preventDefault();
                    }
                }, { passive: false });

                wrapper.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && initialDistance !== null) {
                        const currentDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        
                        const scaleFactor = currentDistance / initialDistance;
                        const oldZoom = this.icicleZoomLevel;
                        this.icicleZoomLevel = Math.max(0.2, Math.min(4.0, oldZoom * scaleFactor));
                        
                        // 计算缩放中心
                        const rect = wrapper.getBoundingClientRect();
                        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                        
                        const unscaledCenterX = (centerX / oldZoom) - this.iciclePanX;
                        const unscaledCenterY = (centerY / oldZoom) - this.iciclePanY;
                        
                        this.iciclePanX = (centerX / this.icicleZoomLevel) - unscaledCenterX;
                        this.iciclePanY = (centerY / this.icicleZoomLevel) - unscaledCenterY;
                        this.iciclePanY = Math.min(0, this.iciclePanY);
                        
                        this._applyIcicleTransform();
                        
                        // 在缩放时更新虚拟滚动
                        if (this.virtualScrollEnabled) {
                            this.scheduleVirtualScrollUpdate();
                        }
                        
                        initialDistance = currentDistance;
                        e.preventDefault();
                    }
                }, { passive: false });

                wrapper.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        initialDistance = null;
                    }
                });

                // 滚轮缩放
                wrapper.addEventListener('wheel', (e) => {
                    if (!this.hasData || this.currentTab !== 1) return;
                    e.preventDefault(); 

                    const scaleFactor = 1.1; 
                    const oldZoom = this.icicleZoomLevel;
                    
                    if (e.deltaY < 0) {
                        this.icicleZoomLevel = Math.min(4.0, oldZoom * scaleFactor);
                    } else {
                        this.icicleZoomLevel = Math.max(0.2, oldZoom / scaleFactor);
                    }
                    
                    const rect = wrapper.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const unscaledMouseX = (mouseX / oldZoom) - (this.iciclePanX);
                    const unscaledMouseY = (mouseY / oldZoom) - (this.iciclePanY);

                    this.iciclePanX = (mouseX / this.icicleZoomLevel) - unscaledMouseX;
                    this.iciclePanY = (mouseY / this.icicleZoomLevel) - unscaledMouseY;
                    
                    this.iciclePanY = Math.min(0, this.iciclePanY); 

                    this._applyIcicleTransform();
                    
                    // 在缩放时更新虚拟滚动
                    if (this.virtualScrollEnabled) {
                        this.scheduleVirtualScrollUpdate();
                    }
                }, { passive: false });
            }
            
            _applyIcicleTransform() {
                const container = document.getElementById('rectangular_tree_container');
                container.style.transform = `translate(${this.iciclePanX}px, ${this.iciclePanY}px) scale(${this.icicleZoomLevel})`;
            }

            // 安排虚拟滚动更新
            scheduleVirtualScrollUpdate() {
                if (this.virtualScrollRafId) {
                    cancelAnimationFrame(this.virtualScrollRafId);
                }
                this.virtualScrollRafId = requestAnimationFrame(() => {
                    this.updateVirtualScroll();
                });
            }

            _getDepthColor(depth, isHighlight = false) {
                const maxDepth = this.icicleMaxDepth || 10; 
                
                let hue; 
                let saturation;
                let lightness;
                let opacity = 0.95;
                
                if (depth === 0) {
                    hue = 85; 
                    saturation = 75;
                    lightness = 55;
                } else {
                    hue = 150; 
                    saturation = 65 - (depth / maxDepth) * 15;
                    lightness = 70 - (depth / maxDepth) * 20;
                }

                if (isHighlight) {
                    hue = 50; 
                    saturation = 90;
                    lightness = 60;
                    opacity = 1.0;
                }

                return `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`;
            }

            getIcicleDecomposition(itemId) {
                // 检查缓存
                if (this.icicleCache.has(itemId)) {
                    return this.icicleCache.get(itemId);
                }

                const item = this.getItemById(itemId);
                if (!item || !item.isDetermined) return null;

                const node = {
                    id: item.id,
                    name: item.name,
                    depth: item.depth,
                    width: item.width,
                    children: []
                };

                if (item.depth === 0) {
                    this.icicleCache.set(itemId, node);
                    return node;
                }

                const simpleRecipes = (this.recipesByProduct.get(itemId) || [])
                    .filter(recipe => recipe.simple === true)
                    .filter(recipe => this.getItemById(recipe.sourceA)?.isDetermined && this.getItemById(recipe.sourceB)?.isDetermined);

                if (simpleRecipes.length === 0) {
                    this.icicleCache.set(itemId, node);
                    return node;
                }
                
                const recipe = simpleRecipes[0];
                
                const childA = this.getIcicleDecomposition(recipe.sourceA);
                if (childA) node.children.push(childA);
                
                if (recipe.sourceA === recipe.sourceB) {
                     if (childA) node.children.push(childA);
                } else {
                    const childB = this.getIcicleDecomposition(recipe.sourceB);
                    if (childB) node.children.push(childB);
                }
                
                if (node.children.length > 0) {
                     node.width = node.children.reduce((sum, child) => sum + child.width, 0);
                } else {
                     node.width = 1;
                }
                
                // 存入缓存
                this.icicleCache.set(itemId, node);
                return node;
            }

            renderRectangularTree() {
                if (!this.hasData) return;
                
                // 如果已经有渲染计划，跳过
                if (this.renderScheduled) return;
                this.renderScheduled = true;
                
                // 使用requestAnimationFrame优化性能
                requestAnimationFrame(() => {
                    const container = document.getElementById('rectangular_tree_container');
                    const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                    const searchName = document.getElementById('icicle_search_input').value.trim().toLowerCase();
                    const searchOnlyRoots = document.getElementById('search_only_roots').checked;
                    
                    const minDepth = parseInt(document.getElementById('min_depth_filter_icicle').value) || 0;
                    const maxDepth = parseInt(document.getElementById('max_depth_filter_icicle').value) || this.icicleMaxDepth + 1;
                    const minWidth = parseInt(document.getElementById('min_width_filter_icicle').value) || 0;
                    const maxWidth = parseInt(document.getElementById('max_width_filter_icicle').value) || 10000; 
                    
                    container.innerHTML = ''; 
                    this._applyIcicleTransform();

                    let icicleRoots = Array.from(this.items.values())
                        .filter(item => item.isDetermined && item.depth > 0);
                    
                    icicleRoots = icicleRoots.filter(item => 
                        item.depth >= minDepth && item.depth <= maxDepth && 
                        item.width >= minWidth && item.width <= maxWidth
                    );
                    
                    if (icicleRoots.length === 0) {
                        container.innerHTML = `<p style="padding: 20px;">根据当前筛选条件，没有发现可分解的元素 (D>0)。</p>`;
                        this.logMessage("冰柱图渲染完成：没有满足筛选条件的元素。", false);
                        this.renderScheduled = false;
                        return;
                    }

                    const trees = icicleRoots.map(rootItem => this.getIcicleDecomposition(rootItem.id)).filter(t => t);
                    
                    // 应用搜索筛选
                    const filteredTrees = trees.filter(tree => {
                        if (!searchName) return true;
                        
                        if (searchOnlyRoots) {
                            // 只搜索根节点
                            return tree.name.toLowerCase().includes(searchName);
                        } else {
                            // 搜索所有节点
                            let found = false;
                            const checkNode = (node) => {
                                if (node.name.toLowerCase().includes(searchName)) { found = true; return; }
                                node.children.forEach(checkNode);
                            };
                            checkNode(tree);
                            return found;
                        }
                    });
                    
                    if (filteredTrees.length === 0) {
                         container.innerHTML = `<p style="padding: 20px;">未找到包含 "${searchName}" 的 Simple 路径。</p>`;
                         this.logMessage(`冰柱图搜索完成：未找到包含 "${searchName}" 的路径。`, false);
                         this.renderScheduled = false;
                        return;
                    }

                    // 性能优化：当没有搜索/筛选时，使用虚拟滚动
                    const hasSearchOrFilter = searchName || 
                        minDepth !== 0 || maxDepth !== (this.icicleMaxDepth + 1) ||
                        minWidth !== 0 || maxWidth !== 10000;
                    
                    this.virtualScrollEnabled = !hasSearchOrFilter && filteredTrees.length > 50;
                    
                    if (this.virtualScrollEnabled) {
                        this.allRoots = filteredTrees;
                        this.renderVirtualScroll();
                    } else {
                        this.renderAllRoots(filteredTrees, searchName);
                    }
                    
                    this.renderScheduled = false;
                });
            }

            // 渲染所有根节点（无虚拟滚动）
            renderAllRoots(filteredTrees, searchName) {
                const container = document.getElementById('rectangular_tree_container');
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                // 重置容器样式
                container.style.position = 'static';
                container.style.display = 'flex';
                container.style.flexDirection = 'row';
                
                const totalIcicleWidthUnits = filteredTrees.reduce((sum, tree) => sum + tree.width, 0);
                const totalChartWidth = totalIcicleWidthUnits * (this.ICICLE_BASE_UNIT_WIDTH) + filteredTrees.length * 2 * this.ICICLE_NODE_MARGIN; 
                
                container.style.width = `${totalChartWidth}px`; 
                
                let targetNodeX = -1; 
                let accumulatedWidth = 0; 
                
                // 使用文档片段优化DOM操作
                const fragment = document.createDocumentFragment();
                
                filteredTrees.forEach(tree => {
                    const rootPixelWidth = tree.width * this.ICICLE_BASE_UNIT_WIDTH + 2 * this.ICICLE_NODE_MARGIN;
                    
                    const rootDiv = document.createElement('div');
                    rootDiv.className = 'icicle-root';
                    rootDiv.style.position = 'relative'; // 使用相对定位
                    rootDiv.style.width = `${rootPixelWidth}px`; 

                    const rootHtml = this._renderIcicleNode(tree, tree.width, searchName, accumulatedWidth, (foundX) => {
                        if (targetNodeX === -1) targetNodeX = foundX;
                    });
                    rootDiv.innerHTML = rootHtml.html;
                    fragment.appendChild(rootDiv);
                    
                    accumulatedWidth += rootPixelWidth;
                });
                
                container.appendChild(fragment);
                
                if (targetNodeX !== -1) {
                    const wrapperRect = wrapper.getBoundingClientRect();
                    const wrapperCenterX = wrapperRect.width / 2;
                    
                    this.iciclePanX = (wrapperCenterX / this.icicleZoomLevel) - targetNodeX;
                    this.iciclePanY = 0; 

                    this._applyIcicleTransform();
                    this.logMessage(`冰柱图搜索定位到 "${searchName}" 结果。`, false);
                } else {
                    this.logMessage(`冰柱图渲染完成，显示 ${filteredTrees.length} 个根元素。`, false);
                }
            }

            // 虚拟滚动实现
            renderVirtualScroll() {
                const container = document.getElementById('rectangular_tree_container');
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                // 设置容器样式
                container.style.position = 'relative';
                container.style.display = 'block';
                
                // 计算虚拟滚动参数
                const totalWidth = this.allRoots.reduce((sum, tree) => sum + tree.width, 0) * this.ICICLE_BASE_UNIT_WIDTH;
                container.style.width = `${totalWidth}px`;
                
                // 初始渲染可见区域
                this.updateVirtualScroll();
                
                this.logMessage(`冰柱图使用虚拟滚动，显示 ${this.allRoots.length} 个根元素。`, false);
            }

            updateVirtualScroll() {
                const container = document.getElementById('rectangular_tree_container');
                const wrapper = document.getElementById('rectangular_tree_container_wrapper');
                
                if (!this.virtualScrollEnabled || !this.allRoots.length) return;
                
                // 计算可见区域（考虑缩放和平移）
                const viewportWidth = wrapper.clientWidth;
                const viewportHeight = wrapper.clientHeight;
                
                // 计算在原始坐标系中的可见区域
                const visibleStartX = -this.iciclePanX / this.icicleZoomLevel;
                const visibleEndX = (-this.iciclePanX + viewportWidth) / this.icicleZoomLevel;
                
                // 添加缓冲区（扩大可见区域范围，防止拖动时出现空白）
                const buffer = viewportWidth / this.icicleZoomLevel * 0.5;
                const visibleStartWithBuffer = Math.max(0, visibleStartX - buffer);
                const visibleEndWithBuffer = visibleEndX + buffer;
                
                // 计算哪些根节点在可见区域内
                let accumulatedWidth = 0;
                const visibleRoots = [];
                
                for (let i = 0; i < this.allRoots.length; i++) {
                    const tree = this.allRoots[i];
                    const rootWidth = tree.width * this.ICICLE_BASE_UNIT_WIDTH;
                    
                    // 检查根节点是否在可见区域内
                    if (accumulatedWidth + rootWidth >= visibleStartWithBuffer && accumulatedWidth <= visibleEndWithBuffer) {
                        visibleRoots.push({
                            tree,
                            startX: accumulatedWidth,
                            index: i
                        });
                    }
                    
                    accumulatedWidth += rootWidth;
                    // 如果已经超过可见区域，可以提前结束
                    if (accumulatedWidth > visibleEndWithBuffer) break;
                }
                
                // 更新DOM
                this.renderVisibleRoots(visibleRoots);
            }

            renderVisibleRoots(visibleRoots) {
                const container = document.getElementById('rectangular_tree_container');
                
                // 创建文档片段，减少DOM操作
                const fragment = document.createDocumentFragment();
                
                // 先隐藏所有现有根节点
                const existingRoots = container.querySelectorAll('.icicle-root');
                existingRoots.forEach(root => {
                    root.style.display = 'none';
                });
                
                // 渲染或更新可见的根节点
                visibleRoots.forEach(({tree, startX, index}) => {
                    const rootPixelWidth = tree.width * this.ICICLE_BASE_UNIT_WIDTH;
                    
                    // 检查是否已经存在这个根节点
                    let rootDiv = container.querySelector(`.icicle-root[data-index="${index}"]`);
                    
                    if (!rootDiv) {
                        // 创建新的根节点
                        rootDiv = document.createElement('div');
                        rootDiv.className = 'icicle-root';
                        rootDiv.setAttribute('data-index', index);
                        rootDiv.style.width = `${rootPixelWidth}px`;
                        rootDiv.style.left = `${startX}px`;
                        
                        const rootHtml = this._renderIcicleNode(tree, tree.width, '', startX);
                        rootDiv.innerHTML = rootHtml.html;
                        
                        fragment.appendChild(rootDiv);
                    } else {
                        // 更新现有根节点的位置
                        rootDiv.style.left = `${startX}px`;
                        rootDiv.style.display = 'block';
                    }
                });
                
                // 一次性更新DOM
                container.appendChild(fragment);
            }

            _renderIcicleNode(node, parentWidthUnits, searchName, currentX, setTargetXCallback) {
                const isHighlight = searchName.length > 0 && node.name.toLowerCase().includes(searchName);
                const color = this._getDepthColor(node.depth, isHighlight);
                
                const nodeWidthPercent = (node.width / parentWidthUnits) * 100;
                
                const nodePixelWidth = node.width * this.ICICLE_BASE_UNIT_WIDTH + 2 * this.ICICLE_NODE_MARGIN;
                
                let html = `<div class="icicle-node-container" style="width: ${nodeWidthPercent}%; min-width: 10px;">`;
                
                html += `<div class="icicle-node-label" 
                            style="background-color: ${color};" 
                            title="ID:${node.id} | D:${node.depth} | W:${node.width}"
                            data-node-id="${node.id}">
                            ${node.name}
                        </div>`;
                
                if (isHighlight && setTargetXCallback && setTargetXCallback.isCalled !== true) {
                    const nodeCenterX = currentX + nodePixelWidth / 2;
                    setTargetXCallback(nodeCenterX);
                    setTargetXCallback.isCalled = true; 
                }

                if (node.children.length > 0) {
                    html += `<div class="icicle-children-container">`;
                    
                    let childAccumulatedX = currentX + this.ICICLE_NODE_MARGIN; 
                    node.children.forEach(child => {
                        const childResult = this._renderIcicleNode(child, node.width, searchName, childAccumulatedX, setTargetXCallback);
                        html += childResult.html;
                        childAccumulatedX += child.width * this.ICICLE_BASE_UNIT_WIDTH + 2 * this.ICICLE_NODE_MARGIN;
                    });

                    html += `</div>`; 
                } else {
                     html += `<div style="flex-grow: 1;"></div>`;
                }

                html += `</div>`; 
                return { html: html, width: nodePixelWidth };
            }

            // 其他方法保持不变...
            initialRenderDAG() {
                if (!this.hasData) return;
                const searchName = document.getElementById('dag_search_input').value.trim();
                const container = document.getElementById('dag_graph_container');
                const searchItem = this.getItemByName(searchName);
                
                if (this.network) this.network.destroy();
                this.network = null;
                this.expandedNodeIds.clear();

                if (!searchName || !searchItem || !searchItem.isDetermined) {
                     container.innerHTML = `<p style="padding: 20px;">请输入一个有效的确定元素名称进行搜索。</p>`;
                     return;
                }

                this.expandedNodeIds.add(searchItem.id);
                
                this.dagNodes = new vis.DataSet();
                this.dagEdges = new vis.DataSet(); 

                this.renderNetwork(); 
                this._updateGraphFromExpandedSet(); 
                
                this.logMessage(`DAG：开始搜索元素 "${searchName}"。`, false);
                
                this.network.once("stabilizationIterationsDone", () => {
                    this.network.setOptions({ physics: false });
                    this.network.focus(searchItem.id, {scale: 1.0, animation: {duration: 500, easingFunction: "easeInOutQuad"}});
                    this.logMessage(`DAG：图表稳定，聚焦到 "${searchName}"。`, false);
                });
            }
            
            toggleNodeExpansion(nodeId) {
                 if (!this.dagNodes.get(nodeId)) return; 

                this.dagNodes.update({ id: nodeId, isExpanding: true, color: { border: '#e53935' } });
                
                if (this.expandedNodeIds.has(nodeId)) {
                    this.expandedNodeIds.delete(nodeId);
                    this.logMessage(`DAG：收起节点 "${this.getItemById(nodeId).name}"。`, false);
                } else {
                    this.expandedNodeIds.add(nodeId);
                    this.logMessage(`DAG：展开节点 "${this.getItemById(nodeId).name}"。`, false);
                }
                
                this._updateGraphFromExpandedSet();

                const isExpanded = this.expandedNodeIds.has(nodeId);
                const isBase = this.getItemById(nodeId)?.depth === 0;
                const newBorderColor = isExpanded ? '#1e88e5' : (isBase ? '#f57c00' : '#3f51b5');
                
                this.dagNodes.update({ 
                    id: nodeId, 
                    isExpanding: false, 
                    label: this.getItemById(nodeId).name, 
                    color: { border: newBorderColor } 
                });
            }

            _updateGraphFromExpandedSet() {
                if (!this.dagNodes || !this.dagEdges || !this.network) return;

                const showNonSimple = document.getElementById('non_simple_toggle')?.checked ?? false;
                const onlyParents = document.getElementById('expand_only_parents')?.checked ?? true;
                const childrenAndPeers = document.getElementById('expand_children_and_peers')?.checked ?? false;
                
                const minDepth = parseInt(document.getElementById('min_depth_filter').value) || 0;
                const maxDepth = parseInt(document.getElementById('max_depth_filter').value) || this.icicleMaxDepth + 1;
                const minWidth = parseInt(document.getElementById('min_width_filter').value) || 0;
                const maxWidth = parseInt(document.getElementById('max_width_filter').value) || 10000; 

                const nodesToKeep = new Set();
                const edgesToKeep = [];
                
                this.expandedNodeIds.forEach(centerId => {
                    const centerItem = this.getItemById(centerId);
                    if (!centerItem || !centerItem.isDetermined) return;
                    
                    nodesToKeep.add(centerId); 
                    
                    if (onlyParents) {
                        const recipesForProduct = this.recipesByProduct.get(centerId) || [];
                        recipesForProduct.forEach(recipe => {
                            if (recipe.simple || showNonSimple) {
                                nodesToKeep.add(recipe.sourceA);
                                edgesToKeep.push(this._createEdgeDefinition(recipe.sourceA, centerId, recipe));
                                
                                if (recipe.sourceA !== recipe.sourceB) {
                                    nodesToKeep.add(recipe.sourceB);
                                    edgesToKeep.push(this._createEdgeDefinition(recipe.sourceB, centerId, recipe));
                                }
                            }
                        });
                    }

                    if (childrenAndPeers) {
                        const recipesForSource = this.recipesBySource.get(centerId) || [];
                        recipesForSource.forEach(recipe => {
                            if (recipe.simple || showNonSimple) {
                                const otherSourceId = recipe.sourceA === centerId ? recipe.sourceB : recipe.sourceA;
                                
                                nodesToKeep.add(recipe.product);
                                edgesToKeep.push(this._createEdgeDefinition(centerId, recipe.product, recipe));
                                
                                nodesToKeep.add(otherSourceId);
                                edgesToKeep.push(this._createEdgeDefinition(otherSourceId, recipe.product, recipe)); 
                            }
                        });
                    }
                });
                
                const filteredNodesToKeep = new Set();
                nodesToKeep.forEach(id => {
                     const item = this.getItemById(id);
                     if (item?.isDetermined && 
                         item.depth >= minDepth && item.depth <= maxDepth && 
                         item.width >= minWidth && item.width <= maxWidth) {
                        filteredNodesToKeep.add(id);
                     }
                });
                
                const initialSearchId = this.getItemByName(document.getElementById('dag_search_input').value.trim())?.id;
                if (initialSearchId && this.expandedNodeIds.has(initialSearchId) && !filteredNodesToKeep.has(initialSearchId)) {
                    this.expandedNodeIds.clear(); 
                    this.dagNodes.clear();
                    this.dagEdges.clear();
                    this.network.setData({ nodes: this.dagNodes, edges: this.dagEdges });
                    this.logMessage("DAG：初始搜索节点被 D/W 筛选器排除，已重置图表。", true);
                    return; 
                }
                
                const currentNodes = this.dagNodes.getIds();
                const nodesToRemove = currentNodes.filter(id => !filteredNodesToKeep.has(id));
                const nodesToAdd = Array.from(filteredNodesToKeep).filter(id => !this.dagNodes.get(id));
                
                const nodesToUpdate = currentNodes.filter(id => filteredNodesToKeep.has(id)).map(id => {
                    const item = this.getItemById(id);
                    const isExpanded = this.expandedNodeIds.has(id);
                    const isBase = item?.depth === 0;
                    
                    const borderColor = isExpanded ? '#1e88e5' : (isBase ? '#f57c00' : '#3f51b5');
                    
                    return {
                        id: id,
                        label: item.name, 
                        color: {
                            border: borderColor
                        }
                    };
                });

                this.dagNodes.remove(nodesToRemove);
                this.dagNodes.update(nodesToUpdate);
                this._addNodesToGraph(nodesToAdd); 

                const uniqueEdges = [];
                const addedEdges = new Set();
                this.dagEdges.clear();
                
                edgesToKeep.forEach(edge => {
                    if (filteredNodesToKeep.has(edge.from) && filteredNodesToKeep.has(edge.to)) {
                        if (!addedEdges.has(edge.id)) {
                            uniqueEdges.push(edge);
                            addedEdges.add(edge.id);
                        }
                    }
                });
                
                this.dagEdges.add(uniqueEdges);

                this.network.setOptions({ physics: true });
                this.network.once("stabilizationIterationsDone", () => {
                    this.network.setOptions({ physics: false });
                    this.network.fit();
                    this.logMessage("DAG：图表筛选/更新完成。", false);
                });
            }

            _createEdgeDefinition(fromId, toId, recipe) {
                const recipeKey = JSON.stringify(recipe.id);
                const isSimple = recipe.simple;
                const edgeId = `${fromId}_to_${toId}_${recipeKey}`;
                
                const edgeColor = isSimple ? '#4caf50' : '#9e9e9e'; 
                const edgeDashes = !isSimple;
                const baseTitle = `${this.getItemById(recipe.sourceA)?.name} + ${this.getItemById(recipe.sourceB)?.name} = ${this.getItemById(recipe.product)?.name}\nSimple: ${isSimple ? 'Yes' : 'No'}`;

                return {
                    id: edgeId,
                    from: fromId,
                    to: toId,
                    arrows: 'to',
                    color: { color: edgeColor }, 
                    dashes: edgeDashes,
                    width: 2,
                    title: baseTitle,
                    isSimple: isSimple
                };
            }

            _addNodesToGraph(itemIds) {
                const nodesToAdd = [];
                itemIds.forEach(itemId => {
                    const item = this.getItemById(itemId);
                    if (!item || !item.isDetermined) return;
                    
                    const isExpanded = this.expandedNodeIds.has(itemId);
                    const isBase = item.depth === 0;

                    const borderColor = isExpanded ? '#1e88e5' : (isBase ? '#f57c00' : '#3f51b5');

                    nodesToAdd.push({
                        id: itemId,
                        label: item.name,
                        title: `ID: ${item.id}\nDepth: ${item.depth}\nWidth: ${item.width}\nExpanded: ${isExpanded ? 'Yes' : 'No'}`,
                        shape: 'box',
                        size: 30, 
                        borderWidth: 3, 
                        font: { color: 'black', size: 14 },
                        isExpanded: isExpanded, 
                        color: {
                            background: isBase ? '#ff9800' : '#bbdefb', 
                            border: borderColor, 
                            highlight: { background: '#ffcdd2', border: '#e53935' }
                        }
                    });
                });
                this.dagNodes.add(nodesToAdd);
            }

            renderNetwork() {
                const container = document.getElementById('dag_graph_container');
                container.innerHTML = ''; 

                const data = { nodes: this.dagNodes, edges: this.dagEdges };
                const options = {
                    layout: { hierarchical: false },
                    edges: {
                        smooth: { type: 'dynamic' },
                        arrows: 'to',
                        width: 1.5,
                    },
                    physics: {
                        enabled: true,
                        barnesHut: {
                            gravitationalConstant: -2000, 
                            centralGravity: 0.1, 
                            springLength: 200, 
                            springConstant: 0.05
                        },
                        stabilization: {
                            iterations: 1000, // 减少迭代次数提高性能
                            updateInterval: 50, 
                            onlyNecessary: true
                        }
                    },
                    interaction: { 
                        dragNodes: true, 
                        zoomView: true, 
                        dragView: true,
                        multiselect: false // 禁用多选提高性能
                    }
                };

                this.network = new vis.Network(container, data, options);

                this.network.on("click", (params) => {
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        this.toggleNodeExpansion(nodeId);
                    }
                });
            }
            
            // 全屏功能
            toggleFullscreen(elementId) {
                const element = document.getElementById(elementId);
                
                if (!document.fullscreenElement) {
                    // 进入全屏
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                    
                    element.classList.add('fullscreen');
                } else {
                    // 退出全屏
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                    
                    element.classList.remove('fullscreen');
                }
            }
        }

        const app = new VisualizationApp();
        
        document.addEventListener('DOMContentLoaded', () => {
            app.setupIcicleZoom();
            app.loadInitialData();
            
            document.getElementById('json_file_input').addEventListener('change', () => {
                if (document.getElementById('json_file_input').files.length > 0) {
                    app.logMessage('文件已选择，请点击 "导入 JSON 数据"。', false);
                } else if (!app.hasData) {
                    app.logMessage('请导入 JSON 数据。', false);
                }
            });
            
            // 监听全屏变化
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);
            
            function handleFullscreenChange() {
                const fullscreenElement = document.fullscreenElement || 
                                         document.webkitFullscreenElement || 
                                         document.msFullscreenElement;
                
                if (!fullscreenElement) {
                    // 退出全屏时移除全屏类
                    document.querySelectorAll('.fullscreen').forEach(el => {
                        el.classList.remove('fullscreen');
                    });
                }
            }
        });
    </script>
</body>
</html>
